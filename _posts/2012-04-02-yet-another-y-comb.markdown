---
layout: post
title: "Очередной Y-комбинатор на C#"
date: 2012-04-02 17:18:39
categories: 20348899021
tags: y combinator csharp delegates
---
В ходе всё ещё тщетных попыток написать на C# типизированную версию клёвого и особо опасного для мозга U-комбинатора (Y-комбинатор без рекурсии):

{% highlight C# %}
Y = (λh.λF.F(λx.((h(h))(F))(x))) (λh.λF.F(λx.((h(h))(F))(x)))
{% endhighlight %}

Получился забавный Y-комбинатор тоже без рекурсии, с рекурсивным типом-делегатом, стало жалко выбрасывать, решил положить здесь:

{% highlight C# %}
delegate β ƒ<α, β>(α x);
delegate α γ<α>(γ<α> f);

static ƒ<α, β> Y<α, β>(ƒ<ƒ<α, β>, ƒ<α, β>> f) {
  return new γ<ƒ<α, β>>(h => F => f(h(h))(F))(h => F => f(h(h))(F));
}
{% endhighlight %}

Осталось взять всеми любимый факториал с аргументами в каррированной форме:

{% highlight C# %}
static ƒ<int, int> Fact(ƒ<int, int> fact) {
  return n => (n == 0) ? 1 : n * fact(n - 1);
}
{% endhighlight %}

И скормить его комбинатору:

{% highlight C# %}
var fact = Y<int, int>(Fact);
Console.WriteLine("fact(6) = {0}", fact(6));
{% endhighlight %}

Поздравляю, теперь вы вооружены на случай, если из C# когда-нибудь дропнут рекурсивные вызовы :)

p.s. U-комбинатор по прежнему в поиске своего типизированного аналога!