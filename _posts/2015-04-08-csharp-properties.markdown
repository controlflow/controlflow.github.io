---
layout: post
title: "Наследие прошлого или property hell"
date: 2015-04-08 17:52:00
tags: csharp properties design
---

Последний год я предпринимал жалкие попытки найти время и заняться оживлением блога, написал десяток драфтов постов, но так ничего и не доделал. Этот пост (если вы его читаете, то я таки его закончил, YAY!) получался особо жирным и тяжелым. Итак, сегодня я предлагаю вам в деталях обсудить понятие "свойства" на примере языка C# и немного поразмышлять о дизайне языков программирования.

### Что это?

Давайте вернемся во времена C# 1.0 и рассмотрим определение канонического DTO-класса, инкапсулирующего некоторые данные. В отличие от Java, декларация класса в C# могла содержать не только поля/методы/классы, но и еще одну разновидность членов класса — декларации свойств:

```c#
class Person {
  private string _name;

  public Person(string name) {
    _name = name;
  }

  // property declaration:
  public string Name {
    get { return _name; }
    set { _name = value; }
  }
}

// property usage:
Person person = new Person();
person.Name = "Alex";
Console.WriteLine(person.Name);
person.Name += " the cat";
```



Свойства представляю собой члены класса, имеющие имя, декларирующие свой тип, а так же содержащие в себе декларации "акцессоров". Акцессоры немного похожи на декларации методов, за исключением, например, явной декларации типа возвращаемого значения и списка формальных параметров. Существуют два вида акцессоров свойств — getter'ы и setter'ы, вызываемых при обращении к свойствам на чтение и запись соответственно. Возможно, на тот момент это казалось языковым средством неземной красоты, по сравнению со шляпой из пары методов в Java (которую шлепают до сих пор, в 2015 году):

```java
class Person {
  private String _name;

  public String getName() {
    return _name;
  }

  public void setName(String value) {
    _value = value;
  }
}

Person person = new Person();
person.setName("Alex");
Console.WriteLine(person.getName());
person.setName(person.getName() + " the cat");
```

### Мотивация

ОК, зачем нам вообще нужны свойства? Дело в том, что в высокоуровневых языках, таких как в Java и C#, поля классов представляют собой достаточно низкоуровневые конструкции<sup>1</sup>. Доступ к полю просто считывает или записывает область памяти некоторого известного размера по некоторому смещению, статически известному среде исполнения. Из такой низкоуровневости полей следует, что:

* Между разными полями и полями разных типов не существует унифицированного "интерфейса" (такого, например, как указатель на исполняемый код), что не позволяет организовать к ним полиморфный доступ (написать код, абстрагированный от знания о конкретном типе, к полю которого он обращается);

* Не существует возможности перехвата обращений к полю для исполнения дополнительных проверок консистентности, инварианта класса.

Помимо этого, практика показывает, что в классах часто удобно выставлять наружу какие-либо данные, не имея их в своем состоянии — то есть вычислять данные по какому-нибудь правилу при каждом обращении, забирать у какого-нибудь внутреннего объекта и т.п.

Все эти проблемы можно было успешно решить существующими в языке средствами — введя пару методов для доступа к значению поля, реализуя ими члены интерфейса или исполняя произвольный код проверок до или после записи:

```c#
interface INamedPerson {
  string GetName();
  SetName(string value);
  int GetYear();
}

class Person : INamedPerson {
  private string _name;

  public string GetName() { return _name; }

  public void SetName(string value) {
    if (value == null) throw new ArgumentNullException("value");
    _value = value;
  }

  public int GetYear() {
    return DateTime.Now.Year;
  }
}
```

Чем неудобно такое решение?

* Мы потеряли привычный синтаксис доступа к данным в полях:

```c#
foo.Value += 42;
// vs
foo.SetValue(foo.GetValue() + 42);
```

* В программе на самом деле никак не выражено, что все три сущности — поле и пара методов — имеют какую-либо *связь*. Методы и поля могут иметь разный уровень видимости, разное имя, разную "статичность" и "виртуальность".

* Чтобы намекнуть на общую связь, мы задекларировали три сущности имеющими подстроку "Name" в именах. При рефакторинге нам придется обновить все три имени. Аналогично с упоминанием типа данных. Подобное соглашение об именовании упрощает жизнь в Java, но носит лишь рекомендативный характер.

### Решение с помощью свойств

```c#
interface INamedPerson {
  string Name { get; set; }
  int Year { get; }
}

class Person : INamedPerson {
  private string _name;

  public string Name {
    get { return _name; }
    set {
      if (value == null) throw new ArgumentNullException("value");
      _name = value;
    }
  }

  public int Year {
    get { return DateTime.Now.Year; }
  }
}
```

Кода по-прежнему невыносимо много (по современным меркам), но определенные удобства свойства все же привнесли:

* Тела акцессоров синтаксически объеденены в один блок, а значит логически разделяют один и тот же уровень видимости, модификаторы статичности и виртуальности;

* Имя `Name` теперь декларируется "всего" два раза, так же как и тип `String`. Параметр `value` декларируется в `set`-акцессоре неявным образом, что тоже экономит немного кода;

* Синтаксис доступа к свойствам аналогичен привычному и простому синтаксису доступа к полю, что еще и значительно облегчает инкапсуляцию поля в свойство вручную;

* За свойством может и вовсе не стоять поля с состоянием, тела акцессоров могут содержать произвольный код;

* Не смотря на то, что акцессоры все равно компилируются в тела методов `string get_Name()` и `set_Name(string value)`, в метаданных хранится специальная запись о свойстве, как о единой сущности (аналогично для событий C#), то есть понятие свойства существует для среды исполнения, это не только сущность компилятора C#.

TODO: из-за того, что свойства существуют для рантайма/в метаданных, то их можно проаннотировать.

Как я не пытался структурировать дальнейшие рассуждения, дальше получился просто вброс из обсуждения

и пересечения свойств

TODO: finish!


### Проблемы с value-типами

Существование типов-значений в языке очень усложняет практически все, что можно представить. Изменяемые типы-значения умножают сложность еще на порядок. Из-за типов-значений 

```c#
struct Box {
  public int Value;
  public void Inc() { Value++; }
}
```

* Вынуждены ввести понятие classified as a variable
* readonly поля ведут себя по-разному
* свойства ведут себя тупее, но неудобнее

### Разновидности доступа

Простой императивный язык программирования — это такой, в коде которого можно увидеть использование (не декларацию!) переменной `foo` и всегда знать, что это либо чтение переменной, либо запись. Но когда-то очень давно случился язык программирования C и теперь у нас есть вот эти мутанты:

```c#
value ++;
value += 42;
```

То есть появляется новая *разновидность* использования — чтение/запись. Так как C# стремится синтаксически устранить различия использования свойств от использования полей, то подобные операторы разрешены и для свойств (доступных для записи), компилируясь в вызовы `get` и `set`-акцессоров:

```c#
++ person.Age;
// is
person.set_Age(person.get_Age() + 1);
```

Казалось бы: замечательно, что это работает — ведь на то и нужен язык высокого уровня, что скрывать низкоуровневые детали реализации свойств как вызовов методов. Проблема в том, что в C# есть еще один источник использований на чтение и запись одновременно — `ref`-параметры:

```c#
void M(ref int x) { x += 42; }

int x = 0;
M(ref x); // read-write usage
```

К сожалению, `ref`/`out`-параметры в C# — не менее низкоуровневые конструкции, чем поля типов. Для среды исполнения `ref`/`out`-параметры имеют специальный управляемый ссылочный тип, отличающегося от обычных unmanaged-указателей только запретом на арифметический операции и осведомленностью GC об объектах по таким указателям (передача поля класса/элемента массива как `ref`/`out`-параметра удерживает весь объект/массив от сборки мусора).

Из-за невозможности превратить два метода акцессоров свойства в один указатель на изменяемую область памяти, компилятор C# банально не позволяет передавать свойства в `ref`/`out`-параметры. Это редко нужно на практике, но выглядит как "спонтанное нарушение симметрии" в языке. Интересно, что другой .NET-язык — Visual Basic .NET — без особых проблем скрывает для пользователя разницу между свойствами и полями:

```vbnet
sub F(byref x as integer)
  x += 1
end sub

interface ISomeType
  property Prop as integer
end interface

dim i as ISomeType = ...
F(i.Prop) ' OK
```

Грубо говоря, VB.NET разрешает передавать в `byref`-параметры вообще любые выражения, автоматически создавая временную локальную переменную (и передавая ее адрес). Если в качестве аргумента `byref`-передано изменяемое свойство, то VB.NET автоматически присвоит свойству значение временной переменной, но только по окончанию вызова. Есть вероятность (крайне маленькая), что метод с `byref`-параметром каким-нибудь магическим образом должен зависеть от актуального значения переданного в него свойства и тогда удобность превратится в грабли.

Но граблей и без этого хватает: например, если взять в скобки `i.Prop` из примера выше, то присвоение свойству перестанет происходить (в качестве `byref`-аргумента начнет передаваться временное значение выражения в скобках, а не само *свойство-как-адрес*). Помимо этого, присвоение свойству не случится если после присвоения `byref`-параметра в методе возникнет исключение. Вот и не понятно становится — стоят-ли эти грабли в языке потерянной универсальности?

### Типизация latency

Одно из самых замечательных последствий существования свойств в C# — это "типизация" задержки. Под "задержкой" я подразумеваю среднее время возвращения исполнения после обращения к некоторому коду. Понятия "задержки" и связанное понятие "эффективности" (очень советую посмотреть [видео с Эриком Мейджером на эту тему](http://channel9.msdn.com/Blogs/Charles/Erik-Meijer-Latency-Native-Relativity-and-Energy-Efficient-Programming)) — практически точно такие же метрики программ, как "O большое" по времени или памяти.

Типизация занимается *классификацией* значений и других сущностей программы. Метрики вида "эта функция вычисляется за *O(n)*" или "эта функция пользуется константным количеством памяти" — вполне могут выступать в роли *типов* и их точно так же можно проверять на корректность (например, запретить вызывать функции, класифицированных как *O(n<sup>2</sup>)*, из *O(n)*-функций). Спроса на такую разновидность типизации я не наблюдал, так же как и языков программирования, способных выразить и валидировать подобные аспекты программ.

С другой стороны, в реальной жизни мы на самом деле часто сталкиваемся с попытками классифицироваия понятия задержки того или иного метода некоторого API. Самый распространенный пример — Promise-объекты. Например, в WinRT (новом провальном системном API приложений для Windows 8) все методы, которые могут исполняться достаточно долго, сделаны только возвращающими значения типов `Task` или `Task<T>`. Все их использования вынуждают пользователя породить асинхронность и быть готовым к задержке (не забивать UI-поток в ожидании окончания тяжелых операций), потому что из `Task<T>` нет легкого способа вытащить значение `T` (за `.Value` или `.Wait()` можно сразу убивать). То есть сущности программы разделяются хотя бы на два класса — пригодные для синхронных вызовов и пригодных только для работы в асинхронном коде.

Свойства в C# — тоже, в некотором роде, типизируют задержку исполняемого кода. От свойства обычно никак не не ожидают, что при доступе оно полезет на диск или в сеть. Это правило конечно же неформальное, никто это не проверяет, существуют известные отклонения (например, свойство `Lazy<T>.Value`), но все же на практике API из методов и свойств позволяет иметь некоторые ожидания от того или иного члена класса в плане "задержки".

### Типизация purity

Другой не менее важный аспект свойств — опять же неформально, но большинством C# разработчиков ожидается, что доступ к свойству на чтение функционально чист. Формальное определение чистоты достаточно сложно дать применительно к C#/.NET, поэтому я буду оперировать какой-нибудь абстрактной чистотой. Здравый смысл позволяет ожидать, что доступ к свойству на чтение не может изменить видимое клиенту состояние класса (то есть вычислить что-то и закэшировать в изменяемом поле — ОК), не делает I/O или запроса к СУБД.

Чистота свойств настолько натуральна и ожидаема, что отладчик VisualStudio не брезгает вызывать любые свойства в окнах отладчика типа Watch — это очень удобно и в 99.99% случаев не имеет никакого эффекта на исполнение программы под отладчиком. Помимо отладчика, IDE-тулингу типа ReSharper для автоматических рефакторингов кода иногда крайне полезно уметь спросить любое выражение языка "а чистый-ли ты, дружок?" — например, чтобы переупорядочить код изменяя порядок вычисления, но сохраняя семантику исходной программы. Конкретно в ReSharper некоторые рефакторинги полагаются на чистоту доступа к свойству (даже не смотря на очевидные отклонения как `System.DateTime.Now`) и жалоб на сломанную семантику программы (после применения рефакторинга) практически никогда не поступало.

```c#
if (foo.Bar != null) foo.Bar.Baz();
```

Код выше *очень распространен* в C#, из-за этого в движке dataflow-анализов ReSharper когда-то давно пришлось поддерживать не только локальные переменные, но еще и собирать знания о значениях полей и свойств, к которым достучались из локальных переменных (как `foo.Bar` из примера выше). При этом такой анализ не является sound (результаты не всегда корректны), он не учитывает потенциальный aliasing ссылок на объекты, панически инвалидирует знания о свойствах/полях при вызовах методов на той или иной переменной. Но что поделать, если такой код пишут регулярно, отдача от анализа должна быть практически мгновенной и до 99% свойств действительно являются чистыми?

### Модификаторы свойств и полиморфизм

Объединяя свойства в одну логическую сущность, в C# мы потеряли возможность управлять виртуальностью каждого акцессора свойства отдельно. Например, нельзя сделать виртуальным только `get`-акцессор. На первый взгляд может показаться, что это и к лучшему - такие модификаторы как `new` (сокрытие базовых членов класса по имени) разумно иметь только для свойства как единого целого. С другой стороны, начиная с C# 1.0 в языке образовались грабли, на которые я периодически наступал:

```c#
abstract class B {
  public abstract int Value { get; }
}

class C : B {
  int _value;
    
  public override int Value {
    get { return _value; }
    set { _value = value; } // CS0546
  }
}
```

Так как модификатор `override` тоже распространяется на оба акцессора, а `set`-акцессору перекрывать в базовом классе нечего, то мы получаем ошибку компиляции:

> Error CS0546: 'C.Value.set': cannot override because 'B.Value' does not have an overridable set accessor

Скажу сразу, что в самой последней версии C# до сих пор вообще не существует способа добавить акцессор в переопределении полиморфного свойства. 

Интересно, что из-за этого становится нетривально не иметь set-only свойства в языке.






TODO: не такая уж и проблема? пахнет кривым кодом


, что это реальная проблема, которую нужно решить.

### Полиморфные акцессоры

Мне всегда казалось, что глядя на декларацию свойства в C# можно однозначно сказать - доступно-ли оно для чтения или записи, просто по списку акцессоров свойства. Взглянув на реализации `IProperty.IsWriteable`/`IProperty.IsReadable` внутри моделей ReSharper я был неприятно удивлен - все три свойства из деклараций классов ниже можно читать и записывать:

```c#
abstract class B {
  public abstract int Value { get; set; }
}

abstract class C : B {
  public override int Value { set { /* ... */ } }
}

class D : C {
  public override int Value { get { return 42; } }
}
```

Если декларация свойства не имеет необходимой декларации акцессора, но имеет модификатор `override`, то чтобы ответить на вопрос записываемости/читаемости свойства, необходимо перейти к семантической модели чтобы обойти иерархию базовых классов и проанализировать наличие в перекрытых свойствах необходимого акцессора.

Дело в том, что переопределение (`override`) свойства не определяет новое свойство, а лишь специализирует акцессоры. Переопределение свойств выглядит уже достаточно запутанной частью языка чтобы делать ее слишком гибкой и запутывать еще больше, конечно следовало бы запретил переопределять акцессоры частично, даже если в большинстве случаев пользователям пришлось бы дописывать акцессор вида `get { return base.Value; }`. Сложно представить случаи, когда частичное переопределение акцессоров не было бы code smell'ом.

### Другие проблемы

Само наличие и полей, и свойств.

* set-only свойства

* value-типы
* classified as variable (сложная тема)

* полиморфизм + отсутствие акцессоров
* ужасный синтаксис

* нет возможности сделегировать реализацию акцессоров

* explicit реализация свойств, 

C# 2.0 - визибилити акцессоров

* полиморфизм + private акцессор = говно какое-то
* private-акцессор не решил проблему overrode-модификатора из C# 1.0 (то же самое с explicit реализацией)
* модификаторы не могут быть у интерфейсов и 

C# 3.0 - автосвойства

* синтаксис и терминология отличается от field-like events
* не мульти-декларация (уже не сделать)
* продолбали инициализаторы
* не повесить атрибут на поле
* в структурах не поюзаешь из-за this
* иммутабельность продолбали
* object initializers

С# 4.0 - проперти-мутанты из COM'а

C# 5.0 - нет async-свойств

C# 6.0 - expression-тела, инициализаторы, get-only автосвойства

* свойства не могут быть generic, из-за этого в F# придумали type functions
* не кинуть исключение в => теле
* сильно отличающийся expression-синтаксис, слишком похоже на филды
* инициализаторы и semicolon в конце (который раньше не требовался)
* полиморфизм + get-only автосвойства = CS8080
* правила вызова акцессора или записи в backing field (как у readonly-полей, но не как с полями)
* починили хаком структуры, пересеклось с parameterless ctor'ами
* += по get-only автосвойствам
* стало сложнее отличать стейт от не-стейта (eще в C# 3.0, теперь от интерфейсного свойства не отличить)
* виртуальность и инициализатор
* появился выбор что использовать внутри класса - поле или свойство, и он нарушался когда приходили к автопропертям
* не понятно что 
* есть нетривиальный +=/-=, но нет ref/out (в VB есть, но )

Другое

* INPC
* first-class
* "хочу свойства рядом с полями"
* IDE + purity of properties
* "типизация" latency
* [Serializable], IXmlSerializable, наличие сеттеров
* Object initializers is a disaster
* no extension properties
* фичи должны проверять и поля, и свойства
* дебаггер!
* в C# уже ничего не починить, господь, жги!
* byref<'a> немного лучше, но не совсем

Идея написать этот поста родилась из обычной рабочей задачи — поддержать C# 6.0 в ReSharper. Как обычно, все задачи оказываются в 2-10 раз сложнее, чем ожидалось. Я догадывался, что реализовать базовую поддержку новых авто-свойств и инициализаторов не составит труда (попарсить, повторить семантические проверки компилятора)

<sup>1</sup> В CLR чтение полей `MarshalByReference` объектов на самом деле всегда виртуальное (до тех пор пока его не передать в `ref`/`out`-параметр).
