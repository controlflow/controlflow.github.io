---
layout: post
title: "Наследие прошлого или property hell"
date: 2015-04-08 17:52:00
tags: csharp properties design
---

Последний год я предпринимал жалкие попытки найти время и заняться оживлением блога, написал десяток драфтов постов, но так ничего и не доделал. Этот пост (если вы его читаете, то я таки его закончил, YAY!) получался особо жирным и тяжелым. Итак, сегодня я предлагаю вам в деталях обсудить понятие "свойства" на примере языка C# и немного поразмышлять о дизайне языков программирования.

## Ликбез по свойствам

### Что это вообще такое?

Давайте вернемся во времена C# 1.0 и рассмотрим определение канонического DTO-класса, инкапсулирующего некоторые данные. В отличие от Java, декларация класса в C# могла содержать не только поля/методы/классы, но и еще одну разновидность членов класса — декларации свойств:

```c#
class Person {
  private string _name;

  public Person(string name) {
    _name = name;
  }

  // property declaration:
  public string Name {
    get { return _name; }
    set { _name = value; }
  }
}

// property usage:
Person person = new Person();
person.Name = "Alex";
Console.WriteLine(person.Name);
person.Name += " the cat";
```

Свойства представляю собой члены класса, имеющие имя, декларирующие свой тип, а так же содержащие в себе декларации "акцессоров". Акцессоры немного похожи на декларации методов, за исключением, например, явной декларации типа возвращаемого значения и списка формальных параметров. Существуют два вида акцессоров свойств — getter'ы и setter'ы, вызываемых при обращении к свойствам на чтение и запись соответственно. Возможно, на тот момент это казалось языковым средством неземной красоты, по сравнению со шляпой из пары методов в Java (которую шлепают до сих пор, в 2015 году):

```java
class Person {
  private String _name;

  public String getName() {
    return _name;
  }

  public void setName(String value) {
    _value = value;
  }
}

Person person = new Person();
person.setName("Alex");
Console.WriteLine(person.getName());
person.setName(person.getName() + " the cat");
```

### Мотивация

ОК, зачем нам вообще нужны свойства? Дело в том, что в высокоуровневых языках, таких как в Java и C#, поля классов представляют собой достаточно низкоуровневые конструкции<sup>1</sup>. Доступ к полю просто считывает или записывает область памяти некоторого известного размера по некоторому смещению, статически известному среде исполнения. Из такой низкоуровневости полей следует, что:

* Между разными полями и полями разных типов не существует унифицированного "интерфейса" (такого, например, как указатель на исполняемый код), что не позволяет организовать к ним полиморфный доступ (написать код, абстрагированный от знания о конкретном типе, к полю которого он обращается);

* Не существует возможности перехвата обращений к полю для исполнения дополнительных проверок консистентности, инварианта класса.

Помимо этого, практика показывает, что в классах часто удобно выставлять наружу какие-либо данные, не имея их в своем состоянии — то есть вычислять данные по какому-нибудь правилу при каждом обращении, забирать у какого-нибудь внутреннего объекта и т.п.

Все эти проблемы можно было успешно решить существующими в языке средствами — введя пару методов для доступа к значению поля, реализуя ими члены интерфейса или исполняя произвольный код проверок до или после записи:

```c#
interface INamedPerson {
  string GetName();
  SetName(string value);
  int GetYear();
}

class Person : INamedPerson {
  private string _name;

  public string GetName() { return _name; }

  public void SetName(string value) {
    if (value == null) throw new ArgumentNullException("value");
    _value = value;
  }

  public int GetYear() {
    return DateTime.Now.Year;
  }
}
```

Чем неудобно такое решение?

* Мы потеряли привычный синтаксис доступа к данным в полях:

```c#
foo.Value += 42;
// vs
foo.SetValue(foo.GetValue() + 42);
```

* В программе на самом деле никак не выражено, что все три сущности — поле и пара методов — имеют какую-либо *связь*. Методы и поля могут иметь разный уровень видимости, разное имя, разную "статичность" и "виртуальность".

* Чтобы намекнуть на общую связь, мы задекларировали три сущности имеющими подстроку "Name" в именах. При рефакторинге нам придется обновить все три имени. Аналогично с упоминанием типа данных. Подобное соглашение об именовании упрощает жизнь в Java, но носит лишь рекомендативный характер.

### Решение с помощью свойств

```c#
interface INamedPerson {
  string Name { get; set; }
  int Year { get; }
}

class Person : INamedPerson {
  private string _name;

  public string Name {
    get { return _name; }
    set {
      if (value == null) throw new ArgumentNullException("value");
      _name = value;
    }
  }

  public int Year {
    get { return DateTime.Now.Year; }
  }
}
```

Кода по-прежнему невыносимо много (по современным меркам), но определенные удобства свойства все же привнесли:

* Тела акцессоров синтаксически объеденены в один блок, а значит логически разделяют один и тот же уровень видимости, модификаторы статичности и виртуальности;

* Имя `Name` теперь декларируется "всего" два раза, так же как и тип `String`. Параметр `value` декларируется в `set`-акцессоре неявным образом, что тоже экономит немного кода;

* Синтаксис доступа к свойствам аналогичен привычному и простому синтаксису доступа к полю, что еще и значительно облегчает инкапсуляцию поля в свойство вручную;

* За свойством может и вовсе не стоять поля с состоянием, тела акцессоров могут содержать произвольный код;

* Не смотря на то, что акцессоры все равно компилируются в тела методов `string get_Name()` и `set_Name(string value)`, в метаданных хранится специальная запись о свойстве, как о единой сущности (аналогично для событий C#), то есть понятие свойства существует для среды исполнения, это не только сущность компилятора C#. Как следствие, свойства можно помечать атрибутами CLI как единую сущность, что имеет множество применений на практике.

Как я не пытался структурировать дальнейшие рассуждения, дальше получились просто перечислить приемущества и недостатки свойств вообще и дизайна свойств конкретно в языке C# самой первой версии.

### Set-only свойства

Тут нечего особо обсуждать - в C# никогда не должно было случиться свойств из единственного `set`-акцессора:

```c#
class Foo {
  public int Property {
    set { SendToDeepSpace(value); }
  }
}
```

Дизайн языка программирования можно сравнить с многомерной задачей оптимизации. Найдя локальный максимум функции от многих переменных (гибкость, функциональность, каноничность, синтаксическая красота и многое другое) может казаться, что выбранный дизайн достаточно хорош. Однако, часто лишь немного сместившись по какому-нибудь из измерений - есть вероятность провалиться в более глубокий максимум.

Например, запрет декларации свойств из одного `set`-акцессора может казаться натуральной "заплаткой" с точки зрения спецификации языка, каким-то искусственным ограничением, разрушающим симметрию между разными типами акцессорами<sup>2</sup> (`get`-акцессоры становятся обязательными). С другой стороны, если не запрещать такие очевидно странные сущности (на такие `set`-only свойства в языке похожи только `out`-параметры, но их становится возможно считывать после первого присвоения), то начинает случаться реальный говнокод с `set`-only свойствами (я ни раз встречал).

Если пару раз наткнуться на такие свойства, не понимая почему их значение не видно в отладчике, то начинаешь ценить совсем не каноничность определения свойства в спецификации, а в количество ~~фашизма~~запретов в компиляторе.

### Разновидности доступа

Простой императивный язык программирования — это такой, в коде которого можно увидеть использование (не декларацию!) переменной `foo` и всегда знать, что это либо чтение переменной, либо запись. Но когда-то очень давно случился язык программирования C и теперь у нас есть вот эти мутанты:

```c#
value ++;
value += 42;
```

То есть появляется новая *разновидность* использования — чтение/запись<sup>3</sup>. Так как C# стремится синтаксически устранить различия использования свойств от использования полей, то подобные операторы разрешены и для свойств (доступных для записи), компилируясь в вызовы `get` и `set`-акцессоров:

```c#
++ person.Age;
// is
person.set_Age(person.get_Age() + 1);
```

Казалось бы: замечательно, что это работает — ведь на то и нужен язык высокого уровня, что скрывать низкоуровневые детали реализации свойств как вызовов методов. Проблема в том, что в C# есть еще один источник использований на чтение и запись одновременно — `ref`-параметры:

```c#
void M(ref int x) { x += 42; }

int x = 0;
M(ref x); // read-write usage
```

К сожалению, `ref`/`out`-параметры в C# — не менее низкоуровневые конструкции, чем поля типов. Для среды исполнения `ref`/`out`-параметры имеют специальный управляемый ссылочный тип, отличающегося от обычных unmanaged-указателей только запретом на арифметический операции и осведомленностью GC об объектах по таким указателям (передача поля класса/элемента массива как `ref`/`out`-параметра удерживает весь объект/массив от сборки мусора).

Из-за невозможности превратить два метода акцессоров свойства в один указатель на изменяемую область памяти, компилятор C# банально не позволяет передавать свойства в `ref`/`out`-параметры. Это редко нужно на практике, но выглядит как "спонтанное нарушение симметрии" в языке. Интересно, что другой .NET-язык — Visual Basic .NET — без особых проблем скрывает для пользователя разницу между свойствами и полями:

```vbnet
sub F(byref x as integer)
  x += 1
end sub

interface ISomeType
  property Prop as integer
end interface

dim i as ISomeType = ...
F(i.Prop) ' OK
```

Грубо говоря, VB.NET разрешает передавать в `byref`-параметры вообще любые выражения, автоматически создавая временную локальную переменную (и передавая ее адрес). Если в качестве аргумента `byref`-передано изменяемое свойство, то VB.NET автоматически присвоит свойству значение временной переменной, но только по окончанию вызова. Есть вероятность (крайне маленькая), что метод с `byref`-параметром каким-нибудь магическим образом должен зависеть от актуального значения переданного в него свойства и тогда удобность превратится в грабли.

Но граблей и без этого хватает: например, если взять в скобки `i.Prop` из примера выше, то присвоение свойству перестанет происходить (в качестве `byref`-аргумента начнет передаваться временное значение выражения в скобках, а не само *свойство-как-адрес*). Помимо этого, присвоение свойству не случится если после присвоения `byref`-параметра в методе возникнет исключение. Вот и не понятно становится — стоят-ли эти грабли в языке потерянной универсальности?

### Пересечение с типами-значениями

Существование типов-значений в языке очень усложняет практически все, что можно представить. Изменяемые типы-значения увеличивают сложность еще на порядок. Одна из причин усложнения языка - введение понятия адреса значения или lvalue (грубо говоря, выражения которое пишется слева от оператора присвоения).

Одна из причин успеха языка программирования Java как раз в простоте языка из-за отсутствия ссылочных и указательных типов, программисту не приходится на практике сталкиваться с понятиями "lvalue" и "rvalue" из мира C/C++. В Java достаточно запомнить, что "адрес" ожидается только слева от знака присвоения и в качестве операнда мутирующих операторов типа `+=` и `++`. Во всех остальных местах языка оперируют только значениями (включая ссылки-на-объекты-как-значения). В C# помимо присвоений и изменяющих значение операторов, адрес ожидается в качестве аргументов `out`-параметров, что не сильно усложняет картину.

Однако в C#, из-за того, что методы и другие члены уровня экземпляра, определенные на структурах, могут изменять эти самые структуры, во все такие члены структур в качестве `this` всегда передается адрес значения (как неявный `ref`-параметр, изменяемый!). То есть даже очень простой код вида `var d = dateTime.AddDays(1);` на самом деле использует переменную `dateTime` как адрес, а не значение, что совершенно незаметно.

На такие случаи спецификация C# вводит понятие выражений, *классифицированных-как-переменная* (*classified as a variable*), чем-то похожее на понятие "lvalue". Однако с этим понятием сопряжено множество нюансов. Например, временные значения (типа возвращаемого значения вызова метода или обращения к свойству на чтение) и чтения `readonly`-полей (вне конструктора) *реклассифицируются* как переменные, чтобы на них все равно можно было вызывать члены структур (вызовы происходят на копии оригинального значения). Со всеми этими нюансами можно разобраться покурив поведение этого кода под отладчиком:

```c#
struct Box {
  public int Value;
  public void Inc() { Value++; }
}

class Foo {
  Box _f;
  readonly Box _r;

  Box _p;
  Box P {
    get { return _p; }
    set { _p = value; } // never actually used
  }

  public Foo() {
    _f.Inc(); // mutates '_f' field, classified as a variable
    _r.Inc(); // mutates '_r' readonly field, classified as a variable
    P.Inc(); // mutates temp value of 'P', reclassified as a variable

    System.Action f = () => {
      _r.Inc(); // mutates temp copy of '_r', reclassified as a variable
    };
  }

  public void InstanceMethod() {
    _f.Inc(); // mutates '_f' field, classified as a variable
    _r.Inc(); // mutates temp copy of '_r', reclassified as a variable
    P.Inc(); // mutates temp value of 'P', reclassified as a variable
  }
}
```

Таким образом свойства ведут себя наиболее простым способом, никогда не играя роль адреса значения. В итоге мы имеем в языке три немного отличающихся поведения для изменяемых полей, `readonly`-полей и свойств. При этом компилятор C# старается защитить нас от очевидных глупостей, запрещая на членах не классифицируемых как переменные (`readonly`-полях и свойствах) с типом типа-значения вызывать конструкции, явно нацеленные на модификацию значения:

```c#
interface IBar {
  Box Box { get; set; }
}

void M(IBar bar) {
  bar.Box.Value ++; // CS1612: Cannot modify the return value of 'IBar.Box'
                    // because it is not a variable
  bar.Box.Value = 42; // CS1612 too
  bar.Box.Inc(); // ok! modifies temp 'Box' value
}
```

Но C# ничего не знает о поведении методов структур (изменяют-ли они значение), поэтому вынужден всегда разрешать их вызовы. На самом деле, C# мог бы попытаться устранить различия в поведении между изменяемыми полями и `get`/`set`-свойствами - в примере выше для того чтобы заставить `bar.Boo.Value++;` работать надо лишь вызвать `set`-акцессор `bar.Boo` и передать измененное выражением `.Value++` значение типа `Box` обратно в `bar`. Но с другой стороны, кажется, что в среднем по больнице разработчики никак не будут ожидать от выражения `bar.Box.Value++;` вызова `set`-акцессора свойства `bar.Box`, ведь все выражение выглядит как доступ на чтение и только `.Value` подвергается модификации.

Стоит заметить, что всех описанных выше проблем и разниц в поведении можно легко избежать, если делать структуры C# неизменяемыми - тогда становится совершенно все равно, на копии значения или адресе что-то вызвали, все работало бы одинаково.

### Типизация задержки

Одно из самых замечательных последствий существования свойств в C# — это "типизация" задержки. Под "задержкой" я подразумеваю среднее время возвращения исполнения после обращения к некоторому коду. Понятия "задержки" и связанное понятие "эффективности" (очень советую посмотреть [видео с Эриком Мейджером на эту тему](http://channel9.msdn.com/Blogs/Charles/Erik-Meijer-Latency-Native-Relativity-and-Energy-Efficient-Programming)) — практически точно такие же метрики программ, как "O большое" по времени или памяти.

Типизация занимается *классификацией* значений и других сущностей программы. Метрики вида "эта функция вычисляется за *O(n)*" или "эта функция пользуется константным количеством памяти" — вполне могут выступать в роли *типов* и их точно так же можно проверять на корректность (например, запретить вызывать функции, класифицированных как *O(n<sup>2</sup>)*, из *O(n)*-функций). Спроса на такую разновидность типизации я не наблюдал, так же как и языков программирования, способных выразить и валидировать подобные аспекты программ.

С другой стороны, в реальной жизни мы на самом деле часто сталкиваемся с попытками классифицироваия понятия задержки того или иного метода некоторого API. Самый распространенный пример — Promise-объекты. Например, в WinRT (новом провальном системном API приложений для Windows 8) все методы, которые могут исполняться достаточно долго, сделаны только возвращающими значения типов `Task` или `Task<T>`. Все их использования вынуждают пользователя породить асинхронность и быть готовым к задержке (не забивать UI-поток в ожидании окончания тяжелых операций), потому что из `Task<T>` нет легкого способа вытащить значение `T` (за `.Value` или `.Wait()` можно сразу убивать). То есть сущности программы разделяются хотя бы на два класса — пригодные для синхронных вызовов и пригодных только для работы в асинхронном коде.

Свойства в C# — тоже, в некотором роде, типизируют задержку исполняемого кода. От свойства обычно никак не не ожидают, что при доступе оно полезет на диск или в сеть. Это правило конечно же неформальное, никто это не проверяет, существуют известные отклонения (например, свойство `Lazy<T>.Value`), но все же на практике API из методов и свойств позволяет иметь некоторые ожидания от того или иного члена класса в плане "задержки".

### Типизация функциональной чистоты

Другой не менее важный аспект свойств — опять же неформально, но большинством C# разработчиков ожидается, что доступ к свойству на чтение функционально чист. Формальное определение чистоты достаточно сложно дать применительно к C#/.NET, поэтому я буду оперировать какой-нибудь абстрактной чистотой. Здравый смысл позволяет ожидать, что доступ к свойству на чтение не может изменить видимое клиенту состояние класса (то есть вычислить что-то и закэшировать в изменяемом поле — ОК), не делает I/O или запроса к СУБД.

Чистота свойств настолько натуральна и ожидаема, что отладчик VisualStudio не брезгает вызывать любые свойства в окнах отладчика типа Watch — это очень удобно и в 99.99% случаев не имеет никакого эффекта на исполнение программы под отладчиком. Помимо отладчика, IDE-тулингу типа ReSharper для автоматических рефакторингов кода иногда крайне полезно уметь спросить любое выражение языка "а чистый-ли ты, дружок?" — например, чтобы переупорядочить код изменяя порядок вычисления, но сохраняя семантику исходной программы. Конкретно в ReSharper некоторые рефакторинги полагаются на чистоту доступа к свойству (даже не смотря на очевидные отклонения как `System.DateTime.Now`) и жалоб на сломанную семантику программы (после применения рефакторинга) практически никогда не поступало.

```c#
if (foo.Bar != null) foo.Bar.Baz();
```

Код выше *очень распространен* в C#, из-за этого в движке dataflow-анализов ReSharper когда-то давно пришлось поддерживать не только локальные переменные, но еще и собирать знания о значениях полей и свойств, к которым достучались из локальных переменных (как `foo.Bar` из примера выше). При этом такой анализ не является sound (результаты не всегда корректны), он не учитывает потенциальный aliasing ссылок на объекты, панически инвалидирует знания о свойствах/полях при вызовах методов на той или иной переменной (вызовы типа `foo.M()` инвалидируют знания о членах типа `foo.Bar`). Но что поделаешь, если такой код пишут регулярно, отдача от анализа должна быть практически мгновенной и >95% свойств действительно являются чистыми функциями при чтении?

### Модификаторы свойств и полиморфизм

Объединяя свойства в одну логическую сущность, в C# мы потеряли возможность управлять виртуальностью каждого акцессора свойства отдельно. Например, нельзя сделать виртуальным только `get`-акцессор. На первый взгляд может показаться, что это и к лучшему - такие модификаторы как `new` (сокрытие базовых членов класса по имени) разумно иметь только для свойства как единого целого. С другой стороны, начиная с C# 1.0 в языке образовались грабли, на которые я пару раз наступал:

```c#
abstract class B {
  public abstract int Value { get; }
}

class C : B {
  int _value;
    
  public override int Value {
    get { return _value; }
    set { _value = value; } // CS0546
  }
}
```

Так как модификатор `override` тоже распространяется на оба акцессора, а `set`-акцессору перекрывать в базовом классе нечего, то мы получаем ошибку компиляции:

> Error CS0546: 'C.Value.set': cannot override because 'B.Value' does not have an overridable set accessor

Скажу сразу, что в самой последней версии C# до сих пор вообще не существует способа добавить акцессор в переопределении полиморфного свойства. Большая-ли это проблема - не понятно, кажется что не особо и проблема. Является-ли необходимость добавить акцессор к полиморфному свойству нормальной практикой - тоже не понятно, больше похоже на code smell.

### Полиморфные акцессоры

Мне всегда казалось, что глядя на декларацию свойства в C# можно однозначно сказать - доступно-ли оно для чтения или записи, просто по списку акцессоров свойства. Взглянув на реализации `IProperty.IsWriteable`/`IProperty.IsReadable` внутри моделей ReSharper, я был неприятно удивлен - все три свойства из деклараций классов ниже можно читать и записывать, не смотря на *синтаксический вид* их деклараций:

```c#
abstract class B {
  public abstract int Value { get; set; }
}

abstract class C : B {
  public override int Value { set { /* ... */ } }
}

class D : C {
  public override int Value { get { return 42; } }
}
```

Если декларация свойства не имеет необходимой декларации акцессора, но имеет модификатор `override`, то чтобы ответить на вопрос записываемости/читаемости свойства, необходимо перейти к *семантической* модели, обойти иерархию базовых классов и проанализировать наличие в переопределенных свойствах необходимого акцессора.

Дело в том, что переопределение (`override`) свойства не определяет новое свойство, а лишь *специализирует* тела акцессоров. Переопределение свойств выглядит уже достаточно запутанной частью языка чтобы делать ее слишком гибкой и запутывать язык еще больше. Я думаю, что следовало бы запретил переопределять акцессоры частично, даже если в большинстве случаев пользователям пришлось бы дописывать акцессор вида `get { return base.Value; }`. Сложно представить случаи, когда частичное переопределение акцессоров не было бы code smell'ом.

### Проблема выбора: свойство или поле

Как только язык предоставляет программисту возможность сделать одно и то же несколькими способами - программисты тут же начинают пользоваться этими всеми возможными способами, это закон! Что еще хуже - устраивать холивары на тему какой из способов лучше, писать разные гайдлайны (а потом еще и тулинг!) и так далее. Из этого следует сделать только один вывод - в дизайне языка программирования важно предоставить пользователю гибкость решать все мыслимые и немыслимые проблемы из его предметной области, но при этом ровно столько гибкости, чтобы та или иная проблема решалась/выражалась *единственным* способом.



ref-ретурн адресов?
WPF и биндинг-фашизм

стайл гайд - поле должно быть приватным



### Проблема выбора: инкапсулировать или нет

Из-за той же пресловутой проблемы выбора, среди C#-программистов существует разногласие по-поводу того, как обращаться к инкапсулированным данным внутри декларации владеющего данными класса. Думаю, как минимум половина разработчиков (включая меня) напишет простой DTO-класс как-нибудь вот так:

```c#
class Person {
  string _name;

  public string Name {
    get { return _name; }
    set {
      if (value == null) throw new ArgumentNullException("value");
      _name = value;
    }
  }

  public Person(string name) {
    if (name == null) throw new ArgumentNullException("name");
    _name = name;
  }

  public void SayHello() {
    Console.WriteLine(_name);
  }
}
```

Я до сих пор не могу объяснить себе, почему обращаться к полю внутри класса мне нравится больше. Даже осознавая, что этот подход чреват проблемами/рефакторингом, если свойство вдруг необходимо будет сделать полиморфным (скорее всего все обращения к нему тоже додны стать полиморфными). Тем более осознавая, что вызов акцессора заинлайнится и в сгенерированном машинном коде будет то же самое обращение к полю, если уж смотреть на все возможные причины.

В любом случае, другая часть C#-разработчиков не видит причин обходить публичный интерфейс инкапусированных данных (не важно, есть там валидация как в примере выше или нет) и внутри декларации класса тоже пользуется только свойством:

```c#
class Person {
  ...

  public Person(string name) {
    Name = name;
  }

  public void SayHello() {
    Console.WriteLine(Name);
  }
}
```

Однако жизнь крайне несправедлива и даже они не могут быть счастливы! Потому что когда-нибудь появится "хороший" программист и сделает класс `Person` неизменяемым (поле `_name` станет `readonly`-полем). В этом случае инициализация просто вынуждена будет происходить через обращение к полю напрямую:

```c#
class Person {
  readonly string _name;

  public string Name { get { return _name; } }

  public Person(string name) {
    if (name == null) throw new ArgumentNullException("name");
    _name = name;
  }

  public void SayHello() {
    Console.WriteLine(Name);
  }
}
```

Забегая вперед, хочется заметить, что второй подход (инкапсулировать доступ когда это возможно) выглядит более каноничным и чаще работающим как надо, а дальнейшее развитие языка позволило обойти необходимость в `readonly`-поле и его инициализации из примера выше.

Однако, и у первого подхода есть свои замечательные стороны: невозможно игнорировать тот факт, что у классов очень часто есть поля, *вообще не нуждающиеся в инкасуляции* через свойства. И доступ к ним возможен *единственым* способом. Чаще всего стиль именование полей и свойств в C# отличается (`_field` и `Property`, например) и тогда становится непонятно, почему доступ к инкапсулированным данным внутри декларации класса должен отличаться. И мы опять приходим к проблеме существования и полей, и свойств...

TODO: пример?



### Ужасный синтаксис


## C# 2.0

Новая версия языка вводит


### Другие проблемы

Само наличие и полей, и свойств.

* ужасный синтаксис



* explicit реализация свойств? не может добавлять акцессоры - это хорошо

* поля для приватных данных, приватные свойства редко встречаются

C# 2.0 - визибилити акцессоров

* полиморфизм + private акцессор = говно какое-то
* private-акцессор не решил проблему override-модификатора из C# 1.0 (то же самое с explicit реализацией)
* модификаторы не могут быть у интерфейсов и explicit-реализаций
* модификатор чтения может иметь видимость ниже

C# 3.0 - автосвойства

* синтаксис и терминология отличается от field-like events
* не мульти-декларация (уже не сделать)
* продолбали инициализаторы
* не повесить атрибут на поле
* в структурах не поюзаешь из-за this
* иммутабельность продолбали
* object initializers is a disaster
* нельзя не инкапсулировать доступ!

С# 4.0 - проперти-мутанты из COM'а

C# 5.0 - нет async-свойств

C# 6.0 - expression-тела, инициализаторы, get-only автосвойства

* свойства не могут быть generic, из-за этого в F# придумали type functions
* не кинуть исключение в => теле
* сильно отличающийся expression-синтаксис, слишком похоже на филды
* инициализаторы и semicolon в конце (который раньше не требовался)
* полиморфизм + get-only автосвойства = CS8080
* правила вызова акцессора или записи в backing field (как у readonly-полей, но не как с полями)
* починили хаком структуры, пересеклось с parameterless ctor'ами
* += по get-only автосвойствам
* стало сложнее отличать стейт от не-стейта (eще в C# 3.0, теперь от интерфейсного свойства не отличить)
* виртуальность и инициализатор
* появился выбор что использовать внутри класса - поле или свойство, и он нарушался когда приходили к автопропертям
* не понятно что 
* есть нетривиальный +=/-=, но нет ref/out (в VB есть, но )
* get-only auto-property explicit implementation + невозможность проинициализировать

Другое


* "хочу свойства рядом с полями"
* [Serializable], IXmlSerializable, наличие сеттеров
* Object initializers is a disaster
* no extension properties
* фичи должны проверять и поля, и свойства
* дебаггер!
* в C# уже ничего не починить, господь, жги!
* byref<'a> немного лучше, но не совсем

Нерешенные проблемы

* INPC
* first-class
* нет возможности сделегировать реализацию акцессоров



Идея написать этот поста родилась из обычной рабочей задачи — поддержать C# 6.0 в ReSharper. Как обычно, все задачи оказываются в 2-10 раз сложнее, чем ожидалось. Я догадывался, что реализовать базовую поддержку новых авто-свойств и инициализаторов не составит труда (попарсить, повторить семантические проверки компилятора)

<sup>1</sup> В CLR чтение полей `MarshalByReference` объектов на самом деле всегда виртуальное (до тех пор пока его не передать в `ref`/`out`-параметр).

<sup>2</sup> В C# уже существуют другие типы членов класса с акцессорами - *события* - для которых компилятор всегда требует определить оба ацессора (`add` и `remove`).

<sup>3</sup> На самом деле я конечно не упоминаю другие типы использований сущностей в C# - использования в XML-документации, использования имен сущностей в операторе `nameof()` из C# 6.0, "частичные" использования на чтение и запись при работе с типами-значениями:

```c#
   Point point;

   point.X = 42;            var x = point.X;
// |     |__ write                  |     |__ read
// |________ partial write          |________ partial read
```

