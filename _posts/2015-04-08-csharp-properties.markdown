---
layout: post
title: "Наследие прошлого или property hell"
date: 2015-04-08 17:52:00
tags: csharp properties design
---

Последний год я предпринимал жалкие попытки найти время и заняться оживлением блога, написал десяток драфтов постов, но так ничего и не доделал. Этот пост (если вы его читаете, то я таки его закончил, YAY!) получался особо жирным и тяжелым. Итак, сегодня я предлагаю вам в деталях обсудить понятие "свойства" на примере языка C# и немного поразмышлять о дизайне языков программирования.

### Что это?

Давайте вернемся во времена C# 1.0 и рассмотрим определение канонического DTO-класса, инкапсулирующего некоторые данные. В отличие от Java, декларация класса в C# могла содержать не только поля/методы/классы, но и еще одну разновидность членов класса - декларации свойств:

```c#
class Person {
  private string _name;

  public Person(string name) {
    _name = name;
  }

  // property declaration:
  public string Name {
    get { return _name; }
    set { _name = value; }
  }
}

// property usage:
Person person = new Person();
person.Name = "Alex";
Console.WriteLine(person.Name);
person.Name += " the cat";
```

Свойства представляю собой члены класса, имеющие имя, декларирующие свой тип, а так же содержащие декларации "акцессоров". Акцессоры немного похожи на декларации методов, за исключением, например, явной декларации типа возвращаемого значения и списка формальных параметров. Существуют два вида акцессоров свойств - getter'ы и setter'ы, вызываемых при обращаении к свойствам при чтении и записи соответственно. Возможно, на тот момент это казалось языковым средством неземной красоты, по сравнению со шляпой из пары методов в Java (которую шлепают до сих пор):

```java
class Person {
  private String _name;

  public String getName() {
    return _name;
  }

  public void setName(String value) {
    _value = value;
  }
}

Person person = new Person();
person.setName("Alex");
Console.WriteLine(person.getName());
person.setName(person.getName() + " the cat");
```

### Мотивация

ОК, зачем нам вообще нужны свойства? Дело в том, что в высокоуровневых языках, таких как в Java и C#, поля классов представляют собой достаточно низкоуровневые конструкции<sup>1</sup>. Доступ к полю просто считывает или записывает область памяти размера по некоторому смещению, статически известному среде исполнения. Из такой низкоуровневости полей следует, что:

* Между разными полями и полями разных типов не существует унифицированного "интерфейса" (такого, например, как указатель на исполняемый код), что не позволяет организовать к ним полиморфный доступ;

* Не существует возможности перехвата обращений к полю для исполнения дополнительных проверок консистентности состояния в поле.

Помимо этого, практика показывает, что в классах часто удобно выставлять наружу какие-либо данные, не имея их в своем состоянии - то есть вычислять данные по какому-нибудь правилу при каждом обращении, забирать у какого-нибудь внутреннего объекта и т.п.

Все эти проблемы можно было успешно решить существующими в языке средствами - введя пару методов для доступа к значению поля, реализуя ими члены интерфейса или исполняя произвольный код проверок до или после записи в поле:

```c#
interface INamedPerson {
  string GetName();
  SetName(string value);
  int GetYear();
}

class Person : INamedPerson {
  private string _name;

  public string GetName() { return _name; }

  public void SetName(string value) {
    if (value == null) throw new ArgumentNullException("value");
    _value = value;
  }

  public int GetYear() {
    return DateTime.Now.Year;
  }
}
```

Чем неудобно такое решение?

* Мы потеряли привычный синтаксис доступа к данным в полях:

```c#
foo.Value += 42;
// vs.
foo.SetValue(foo.GetValue() + 42);
```

* В программе на самом деле никак не выражено, что все три сущности - поле и пара методов - имеют какую-либо *связь*. Методы и поля могут иметь разный уровень видимости, разное имя, разную статичность и "виртуальность".

* Чтобы намекнуть на общую связь, мы задекларировали три сущности имеющими подстроку "Name" в именах. При рефакторинге нам придется обновить все три имени. Аналогично с упоминанием типа данных. Подобное соглашение об именовании упрощает жизнь в Java, но носит лишь рекомендативный характер.

### Решение с помощью свойств

```c#
interface INamedPerson {
  string Name { get; set; }
  int Year { get; }
}

class Person : INamedPerson {
  private string _name;

  public string Name {
    get { return _name; }
    set {
      if (value == null) throw new ArgumentNullException("value");
      _name = value;
    }
  }

  public int Year {
    get { return DateTime.Now.Year; }
  }
}
```

Кода по-прежнему невыносимо много, но определенные удобства свойства привнесли:

* Кода все же чуть поменьше, тела акцессоров логически объеденены (как в декларации интерфейса, так и в декларации класса);

* Имя `Name` теперь декларируется "всего" два раза, так же как и тип `String`;

* Параметр `value` декларируется в setter'е неявным образом, что экономит немного кода;

* Синтаксис доступа к свойствам аналогичен привычному и простому синтаксису доступа к полю, что еще и значительно облегчает инкапсуляцию поля в свойство вручную;

* За свойством может и вовсе не стоять поля с состоянием, тела акцессоров могут быть произвольными;

* Не смотря на то, что акцессоры все равно компилируются в тела методов `string get_Name()` и `set_Name(string value)`, в метаданных хранится специальная запись о свойстве, 

### Новые проблемы



### Проблемы с value-типами

Существование типов-значений в языке очень усложняет все.



### Типизация latency

Одно из самых замечательных последствий существования свойств в C# - это "типизация" задержки. Под "задержкой" я подразумеваю среднее время возвращения исполнения кода после обращения к свойству или методу. Задержка и связанное понятие "эффективности" (очень советую посмотреть [видео с Эриком Мейджером на эту тему](http://aaa)) - точно такие же метрики программ, как "O большое" по времени или памяти.

Типизация занимается классификациями значений и других сущностей программы. Метрики вида "эта функция вычисляется за *O(n)*" или "эта функция пользуется константным количеством памяти" - вполне могут считаться *типами* и их точно так же можно проверять на корректность (например, запретить вызывать функции, класифицированных как *O(n<sup>2</sup>)*, из *O(n)*-функций). Спроса на такую разновидность типизации я не наблюдал, так же как и языков программирования, способных выразить и валидировать подобные аспекты программ.

Однако, в реальной жизни мы на самом деле часто сталкиваемся с попытками классифицироваия, например, понятия задержки того или иного метода некоторого API. Самый распространенный пример - Promise-объекты. Например, в WinRT (новом провальном API приложений для Windows 8) все методы, которые могут исполняться достаточно долго, сделаны только возвращающими `Task` или `Task<T>`. Все их использования вынуждают пользователя породить асинхронность и быть готовым к задержке (не забивать UI-поток работой), потому что из `Task<T>` нет легкого способа вытащить значение `T` (монады in action!). То есть сущности программы разделяются хотя бы на два класса - пригодные для синхронных вызовов и пригодных только для работу в асинхронной манере.



### Типизация purity




### Другие проблемы



Само наличие и полей, и свойств.


* value-типы
* classified as variable (сложная тема)
* ref/out-параметры

* полиморфизм + отсутствие акцессоров
* ужасный синтаксис

C# 2.0 - визибилити акцессоров

* полиморфизм + private акцессор = говно какое-то

C# 3.0 - автосвойства

* не мульти-декларация (уже не сделать)
* продолбали инициализаторы
* не повесить атрибут на поле
* в структурах не поюзаешь из-за this
* иммутабельность продолбали

С# 4.0 - проперти-мутанты из COM'а

C# 5.0 - нет async-свойств

C# 6.0 - expression-тела, инициализаторы, get-only автосвойства

* свойства не могут быть generic, из-за этого в F# придумали type functions
* не кинуть исключение в => теле
* сильно отличающийся expression-синтаксис, слишком похоже на филды
* инициализаторы и semicolon в конце (который раньше не требовался)
* полиморфизм + get-only автосвойства = CS8080
* правила вызова акцессора или записи в backing field (как у readonly-полей, но не как с полями)
* починили хаком структуры, пересеклось с parameterless ctor'ами
* += по get-only автосвойствам
* стало сложнее отличать стейт от не-стейта (eще в C# 3.0, теперь от интерфейсного свойства не отличить)
* виртуальность и инициализатор
* появился выбор что использовать внутри класса - поле или свойство, и он нарушался когда приходили к автопропертям

Другое

* INPC
* first-class
* "хочу свойства рядом с полями"
* IDE + purity of properties
* "типизация" latency
* [Serializable], IXmlSerializable, наличие сеттеров
* Object initializers is a disaster
* no extension properties
* фичи должны проверять и поля, и свойства
* дебаггер!

Идея написать этот поста родилась из обычной рабочей задачи - поддержать C# 6.0 в ReSharper. Как обычно, все задачи оказываются в 2-10 раз сложнее, чем ожидалось. Я догадывался, что реализовать базовую поддержку новых авто-свойств и инициализаторов не составит труда (попарсить, повторить семантические проверки компилятора)

<sup>1</sup> В CLR чтение полей `MarshalByReference` объектов на самом деле всегда виртуальное (до тех пор пока его не передать в `ref`/`out`-параметр).
