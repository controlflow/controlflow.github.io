---
layout: post
title: "Наследие прошлого или property hell (часть 4)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 3.0 - все пропало

Релиз версии 3.0 языка C# был самым ярким релизом языка, во многом задавшим направление и темп дальнейшего развития C#. Новые языковые средства, позаимствованные из функциональных языков (простой вывод типов, лямбда-выражения, `from`-выражения) сделали язык гораздо более мультипарадигменным и явно выигрывающим в выразительности у Java - императивным ОО-языком того же класса.

Версия 3.0 языка адресовала проблемы выразительности доступа к данным, предоставив нам удобные функции высшего порядка, цитирование кода через деревья выражений, анонимные типы и методы-расширения, упрощеное конструирование объектов с помощью object initializers. Но самым важным для нас сейчас является новый способ декларации тривиальных свойств - *авто-свойства*.

Интересно, что на момент версии 2.0, в языке уже существовал механизм, крайне похожий на авто-свойства C# 3.0 - *field-like события* (я затрудняюсь нормально перевести название этого языкового средства). Выглядели они действительно похожими на поля, вот только имели специальный модификатор `event`:

```c#
class C {
  public event EventHandler SmthHappened;
}
```

Точно так же, как и поля в C#, field-like события являлись *мульти-декларацией* (кроме деклараций событий с явными `add`/`remove`-акцессорами) и поддерживали синтаксис инициализаторов:

```c#
class C {
  public event EventHandler E1, E2, E3 = delegate { };
}
```

Доступ к field-like событиям (за исключением операторов `+=` и `-=`) внутри владеющего им класса превращался в доступ к генерируюемому компилятором полю (для хранения делегатов подписчиков на событие) с именем, эквивалентным имени события. Это поле было доступно даже для аннотации атрибутом, просто указав `field:` в начале секции атрибутов:

```c#
class C {
  [field: FieldAttribute]
  [EventAttribute]
  public event EventHandler AutoPropertyDesigned;

  private void OnAutoPropertyDesigned() {
    AutoPropertyDesigned(this, EventArgs.Empty); // direct field access
  }
}
```

Несмотря на некоторые ошибки дизайна (например, подписки на такие события в многопоточной среде, защита пользователей от неожиданных NullReferenceException и интересные пересечения с полиморфизмом), дизайн field-like событий можно считать успешным. Даже терминология подчеркивала функциональное и синтаксическое сходство с полями C#, и наличие сгенерированного за событием поля с делегатом.

### История одного авто-свойства

В итоге, в версии 3.0 языка C# мы получили новое языковое средство - *автоматически реализованное свойство* (*automatically-implemented property*) или просто *авто-свойство*. От обычной декларации свойства, авто-свойство отличает только декларации акцессоров без блоков тел:

```c#
class C {
  public string Text { get; set; }
}
```

Мне кажется, что это языковое средство разрабатывал человек, совершенно не оглядывающийся на спецификацию языка 2.0. Как вы наверное догадываетесь, *ничего общего* с field-like событиями у этой конструкции просто нет.

* Авто-свойство не поддерживает синтаксис инициализаторов;
* Авто-свойство не является мульти-декларацией;
* Синтаксис авто-свойства не похоже на декларацию поля из-за уродливого блока с деларациями акцессоров;
* У пользователя нет доступа к генерируемому полю авто-свойства, даже для аннотации его атрибутом (что гораздо важнее для свойств, как частых участников разнообразных сериализаций);
* Терминология "automatically-implemented property" не намекает на связь с field-like с событиями, не намекает на наличие состояние у такой декларации свойства. Я часто не могу вразумительно объяснить людям вне .NET-стека почему мы называем тривиальные члены класса с состоянием с приставкой "авто", так как никому в голову не приходит, что трививальное хранение состояния можно обозвать "автоматической реализацией".

Можно долго рассуждать почему дизайн был столько недоработанным, делался ли релиз в спешке, кто занимался дизайном авто-свойств и чем он думал... Можно даже представить себе C# с *field-like свойствами* и придумать решения для очевидных проблем (типа пересечение с имеющимися в языке модификаторами доступа на акцессорах, которых в предложенном ниже синтаксисе просто нет):

```c#
class C {
  public property int Id;
  public property string Text = string.Empty;
}
```

Однако все решения дизайна авто-свойств были приняты и зарелизены так давно, что теперь гораздо продуктивнее рассуждать как нам дальше с этим жить и какие из проблем реально починить в следующих версиях языка.

### Неизменяемость? Не, не слышал

Еще одним большим расстройством, привнесенным авто-свойствами стало требование определять оба акцессора.


Можно задуматься почему совсем не были адресованы проблемы изменяемого состояния (неизменяемость очень глубоко связана с функциональным программированием, так повлиявшим на C# 3.0), так как в декларации авто-свойства нельзя опускать декларацию `set`-акцессора. Можно лишь занизить уровень доступа до минимального и не модифицировать авто-свойство внутри класса, что достаточно большинству пользователей:

```c#
class C {
  public string Text { get; private set; }
}
```

TODO: нельзя override абстрактному или явную реализацию

### Пересечение авто-свойств со структурами

Сокрытие от пользователя полей авто-свойств может рассматриваться как позитивное отличие от дизайна field-like событий, однако имеющее негативное пересечение с анализом инициализации в декларациях конструкторов структур C#. Дело в том, что в коде деклараций конструкторов структур выполняется проверка инициализации всех *полей* структуры до использования `this` структуры. К сожалению, вызов `set`-акцессора авто-свойства как раз является использованием `this` (если свойство не статическое), а поля авто-свойства невозможно проинициализировать напрямую, так как их невожможно упомянуть в коде:

```c#
struct Rect {
  public int Width { get; private set; }
  public int Height { get; private set; }

  public Rect(int width, int height) {
    this.Width = width; // error
    this.Height = height; // error
  }
}
```

Эта проблема обходится простым вызовом конструктора по-умолчанию перед текущим конструктором (IDE-инструментарию приходится помнить об этом), но таким образом мы грубо избавляемся и от самого анализа инициализации (от него все же бывает польза):

```c#
struct Rect {
  public Rect(int width, int height) : this() {
    this.Width = width; // OK
    ...
  }
}
```

### Проблема отсутсвия выбора: инкапсуляция






* иммутабельность продолбали
* не реализовать абстрактное или explicit-свойство из-за наличия
* object initializers is a disaster
* нельзя не инкапсулировать доступ!
