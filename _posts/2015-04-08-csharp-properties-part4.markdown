---
layout: post
title: "Наследие прошлого или property hell (часть 4)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 3.0 - история одного авто-свойства

Релиз версии 3.0 языка C# 3.0 был самым ярким релизом языка, во многом задавшем направление и темп дальнейшего развития.



явное 
 явно очертивший свое преимущество над 




Иногда мне кажется, что с дизайном авто-свойств пошло не так буквально все.

На момент версии 2.0, в языке уже существовал *механизм*, крайне похожий на авто-свойства C# 3.0 - field-like события (я затрудняюсь нормально перевести название этого языкового средства). Выглядели они действительно крайне похожими на поля, вот только имели специальный модификатор `event`:

```c#
class E {
  public event EventHandler SmthHappened;
}
```

Точно так же, как и поля в C#, field-like события являлись *мульти-декларацией* (кроме деклараций событий с явными `add`/`remove`-акцессорами) и поддерживали синтаксис инициализаторов:

```c#
class E {
  public event EventHandler E1, E2, E3 = delegate { };
}
```

Доступ к field-like событиям (за исключением операторов `+=` и `-=`) внутри владеющего им класса превращался в доступ к генерируюемому компилятором полю (для хранения делегатов подписчиков на событие) с именем, эквивалентным имени события. Это поле было доступно даже для аннотации атрибутом, просто указав цель `field:` в секции атрибутов:

```c#
class E {
  [field: FieldAttribute]
  [EventAttribute]
  public event EventHandler AutoPropertyDesigned;

  private void OnAutoPropertyDesigned() {
    AutoPropertyDesigned(this, EventArgs.Empty); // direct field access
  }
}
```

Несмотря на некоторые ошибки дизайна (например, подписки на field-like события в многопоточной среде, защита пользователей от неожиданных NullReferenceException и пересечение с полиморфизмом), дизайн field-like событий можно считать успешным. Даже терминология подчеркивала и функциональное сходство с полями C#, и наличие сгенерированного за событием поля с делегатом.

### История одного авто-свойства





"Automatically-implemented property"
"Auto-property"
"Auto" is a disaster

### Пересечение автосвойств со структурами

C# 3.0 - автосвойства

* синтаксис и терминология отличается от field-like events
* не мульти-декларация (уже не сделать)
* продолбали инициализаторы
* не повесить атрибут на поле
* в структурах не поюзаешь из-за this
* иммутабельность продолбали
* object initializers is a disaster
* нельзя не инкапсулировать доступ!

С# 4.0 - проперти-мутанты из COM'а

C# 5.0 - нет async-свойств

C# 6.0 - expression-тела, инициализаторы, get-only автосвойства

* свойства не могут быть generic, из-за этого в F# придумали type functions
* не кинуть исключение в => теле
* не повесить атрибут на геттер
* сильно отличающийся expression-синтаксис, слишком похоже на филды
* инициализаторы и semicolon в конце (который раньше не требовался)
* полиморфизм + get-only автосвойства = CS8080
* правила вызова акцессора или записи в backing field (как у readonly-полей, но не как с полями)
* починили хаком структуры, пересеклось с parameterless ctor'ами
* += по get-only автосвойствам
* стало сложнее отличать стейт от не-стейта (eще в C# 3.0, теперь от интерфейсного свойства не отличить)
* виртуальность и инициализатор
* появился выбор что использовать внутри класса - поле или свойство, и он нарушался когда приходили к автопропертям
* не понятно что 
* есть нетривиальный +=/-=, но нет ref/out (в VB есть, но )
* get-only auto-property explicit implementation + невозможность проинициализировать

Другое

* 
* "хочу свойства рядом с полями"
* [Serializable], IXmlSerializable, наличие сеттеров
* Object initializers is a disaster
* no extension properties
* фичи должны проверять и поля, и свойства
* дебаггер!
* в C# уже ничего не починить, господь, жги!
* byref<'a> немного лучше, но не совсем

Нерешенные проблемы

* INPC
* first-class
* нет возможности сделегировать реализацию акцессоров
* [DebuggerDisplay]
* порядок акцессоров
* нельзя сделать делегат из свойства
* нет делегирования

### Другие проблемы

* property-scoped fields
* explicit реализация свойств? не может добавлять акцессоры - это хорошо
* поля для приватных данных, приватные свойства редко встречаются
