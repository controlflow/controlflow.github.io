---
layout: post
title: "Наследие прошлого или property hell (часть 3)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 2.0

Первое обновление языка C# не только принесло всем нам радость параметрическому полиморфизму (generics), но и адресовало некоторые из проблем дизайна свойств.

### Модификаторы доступа на акцессорах

Одна из проблем трактования акцессоров свойств как единого целого заключается в ограничении гибкости. Самым острым последствием того, что различные модификаторы могла иметь только декларация свойства (но не декларации акцессоров) явля

 C# 2.0

```c#
class C {
  
}
```

Не могу

### Модификаторов доступа и полиморфизм

Чем больше в средствах языка программирования разных параметров/осей/измерений, тем больше вероятность их пересечения в самых неожиданных местах. Чем более ортогональными кажутся средства языка, тем больше вероятность что они все же пересекаются и разработчик компилятора не обработает эти пересечения должным образмом.

 Кажется, как раз такая ситуация произошло с модификаторами доступа акцессоров и полиморфизмом свойств:

```c#
abstract class B {
  public abstract int Value { get; }
}

class C : B {
  int _value;

  public override int Value {
    get { return _value; }
    private set { _value = value; } // CS0546
  }
}
```

Компилятор радостно сообщает нам о невозможности переопределить `set`-акцессор базового свойства, игнорируя модификатор доступа, не совместимый с виртуальностью (в C# полиморфные члены не могут быть виртуальными):

> Error CS0546: 'C.Value.set': cannot override because 'B.Value' does not have an overridable set accessor

Интересно, что модификатор `override` тоже 

Таким образом, 

### Generic-свойства?

Value functions

```c#
ImmutableList.Empty<T>();

var set = ImmutableSet.Empty<int>.Add(42);
```


## C# 3.0

LINQ и функциональные фишечки, рекорды.

### История одного автосвойства

"Automatically-implemented property"
"Auto-property"
"Auto" is a disaster

### Пересечение автосвойств со структурами




### Другие проблемы

* property-scoped fields

* explicit реализация свойств? не может добавлять акцессоры - это хорошо

* поля для приватных данных, приватные свойства редко встречаются

C# 2.0 - визибилити акцессоров

* полиморфизм + private акцессор = говно какое-то
* private-акцессор не решил проблему override-модификатора из C# 1.0 (то же самое с explicit реализацией)
* модификаторы не могут быть у интерфейсов и explicit-реализаций
* модификатор чтения может иметь видимость ниже

C# 3.0 - автосвойства

* синтаксис и терминология отличается от field-like events
* не мульти-декларация (уже не сделать)
* продолбали инициализаторы
* не повесить атрибут на поле
* в структурах не поюзаешь из-за this
* иммутабельность продолбали
* object initializers is a disaster
* нельзя не инкапсулировать доступ!

С# 4.0 - проперти-мутанты из COM'а

C# 5.0 - нет async-свойств

C# 6.0 - expression-тела, инициализаторы, get-only автосвойства

* свойства не могут быть generic, из-за этого в F# придумали type functions
* не кинуть исключение в => теле
* сильно отличающийся expression-синтаксис, слишком похоже на филды
* инициализаторы и semicolon в конце (который раньше не требовался)
* полиморфизм + get-only автосвойства = CS8080
* правила вызова акцессора или записи в backing field (как у readonly-полей, но не как с полями)
* починили хаком структуры, пересеклось с parameterless ctor'ами
* += по get-only автосвойствам
* стало сложнее отличать стейт от не-стейта (eще в C# 3.0, теперь от интерфейсного свойства не отличить)
* виртуальность и инициализатор
* появился выбор что использовать внутри класса - поле или свойство, и он нарушался когда приходили к автопропертям
* не понятно что 
* есть нетривиальный +=/-=, но нет ref/out (в VB есть, но )
* get-only auto-property explicit implementation + невозможность проинициализировать

Другое


* "хочу свойства рядом с полями"
* [Serializable], IXmlSerializable, наличие сеттеров
* Object initializers is a disaster
* no extension properties
* фичи должны проверять и поля, и свойства
* дебаггер!
* в C# уже ничего не починить, господь, жги!
* byref<'a> немного лучше, но не совсем

Нерешенные проблемы

* INPC
* first-class
* нет возможности сделегировать реализацию акцессоров


