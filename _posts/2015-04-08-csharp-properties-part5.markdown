---
layout: post
title: "Дизайн и эволюция свойств в C# (часть 5)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 4.0 и 5.0 - спасибо и на этом

Последовавшие за 3.0 релизы языка всегда были посвящены какому-то относительно большому направлению работ (`dynamic` и `async`) и не вносили качественных изменений в дизайн свойств.

### Свойства-мутанты из COM'а

Из-за того, в COM существуют свойства с формальными параметрами, а C# при потреблении метаданных игнорирует большинство сущностей, невыразимых в самом C#, то код работы с подобными COM-объектами выглядит как-то так:

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.get_Range("A1").Value = 42;
  spreadsheet.set_Width("B1", comSpreadsheet.get_Width("B1") + 1);
}
```

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.Range["A1"].Value = 42;
  spreadsheet.Width["B1"] += 1;
}
```

### Асинхронные свойства? Нет, спасибо

В версии языка 2.0, в C# были введены методы-итераторы, но не все знают что конструкции `yield return`/`yield break` прекрасно работают еще и в `get`-акцессорах свойств (не существует значительных причин запрещать такие конструкции):

```c#
class C {
  public IEnumerable<int> ImportantValues {
    get {
      yield return -1;
      yield return 0;
      yield return 42;
    }
  }
}
```

Однако, в отличие от свойств-итераторов, C# 5.0 не стал вводить поддержку `async`-свойств. Опять же, с одной стороны это нарушает симметрию между методами и свойствами (которая, правда, и так уже много раз нарушена), а IDE должны все это обрабатывать (например, в рефакторингах типа "Convert method to property"). С другой стороны - конечно же асинхронный код явно не вписываются в концепцию чистоты и низкой задержки свойств, обсуждаемые нами ранее. Есть и другие проблемы: например, пришлось бы разрешать дополнительный модификатор `async` только на `get`-акцессоре (от модификатора нельзя избавиться из соображений обратной совместимости) и строго требовать от свойства возвращаемый тип `Task<T>`:

```c#
class C {
  public Task<int> Value {
    async get { return 42; }
  }
}
```

Выглядит это все крайне странно и бесполезно, при надобности легко обойти делегированием к `async`-методу, поэтому я доволен отсутствием `async`-свойств в C# (некоторые люди [все же просят](https://github.com/dotnet/roslyn/issues/3015)).

## C# 6.0 - одумались?

Последий (на момент написания статьи) релиз языка C# 6.0 ознаменовал завершение более чем пятилетнего переписывания компиляторов C# и VB.NET на управляемый код, в ходе которого команда не ставила перед собой задачу внесения в язык каких-либо "больших" языковых средств. Сфокусировавшись на относительно мелких улучшениях, C# 6.0 делает попытки исправить значительные недостатки дизайна свойтств, что не может не радовать.

### Свойства с телом-выражением

Программируя на языках с C-подобным синтаксисом, все мы сталкивались с большим количеством тривиальных методов-"однострочников", особенно состоящих из единственного `return`-statement'а. C# 6.0 пытается адресовать проблему синтаксического шума из-за необходимости в блоке и statement'е, вводя для деклараций методов (и операторов, но не конструкторов) синтаксис тел-выражений, аналогичных привычному C# разработчикам синтаксису тел лямбда-выражений:

```c#
class C {
  public int StatementBodiedMethod(int x) { return x + 42; }
  public int ExpressionBodiedMethod(int x) => x + 42;
}
```

Конечно же, дизайнеры языка C# не могли обойти стороной и синтаксис более сложных (синтаксически) членов типов, имеющие внутри себя декларации знакомых нам акцессоров - свойства и индексаторы:

```c#
class C {
  public int StatementBodiedProperty { get { return 42; } }
  public int ExpressionBodiedProperty => 42;

  public string this[int index] { get { return index.ToString(); } }
  public string this[int index] => index.ToString();
}
```

Как можно заметить, в этом случае синтаксический сахар тел-выражений скрывает за собой немного больше, чем в случае методов и операторов - отсутствует явная декларация `get`-акцессора. Таким образом, в синтаксис с телом-выражения могут быть переписаны свойства только с единственным `get`-акцессором (с `public` уровнем доступа) без атрибутов:

```c#
abstract class A {
  public virtual int Value { protected get; set; }
  public virtual string Text { get; set; }
}

class C : A {
  public override int Value => 42; // error
  public override string Text {
    [SomeAttribute] get { return "abc"; }
  }
}
```

Оба случая крайне редкие (за первый надо жестоко наказывать), поэтому ничего страшного в подобных ограничениях нет, лишь немного больше работы для IDE. Однако, из-за таких мелочей мы на самом деле не можем полагаться, что каждое свойство только для чтения можно переписать в вид с телом-выражением. Более того, не смотря на синтаксис, который как-бы говорит "я - вычисляемое свойство только для чтения", из-за описанных ранее полиморфных акцессоров, свойство с телом-выражением вполне может быть доступно и для записи:

```c#
class A {
  public virtual int Value { get; set; }
}

class C : A {
  public override int Value => 42; // readonly? no
  public void M() {
    Value ++; // ok
  }
}
```

### Немного о синтаксисе тел-выражений

Нововведения C# 6.0 у меня вызывали сначала только положительные эмоции, так как наконец адресавали известные проблемные места языка. Например, понимаешь, что вокруг языка просто исчезнут разные бесполезные споры как форматировать тривиальные свойства (правда, могут начаться споры использовать ли вообще свойства с телами-выражениями):

```c#
class C : B {
  public override bool CanRead {
    get {
      return true;
    }
  }
  // vs.
  public override bool CanRead {
    get { return true; }
  }
  // vs.
  public override bool CanRead { get { return true; } }
  // vs.
  public override bool CanRead => true;
}
```

Задумавшись немного глубже, становится страшно представлять как придется объяснять новичку в C# в чем разница между двумя языковыми конструкциями, различающиеся буквально одним символом:

```c#
class C {
  public int Field = 42;
  public int Property => 42;
}
```

Почему после `=` выражение находится в статическом контексте и вычисляется при инициализации класса, а выражение после `=>` вычисляется каждый раз и позволяет пользоваться `this`? Синтаксис тел-выражений смазывает различие между совершенно разными конструкциями, предназначенными для разных целей, только с опытом программирования на C# вырабатывается, в некотором роде, ожидание от конструкции с токеном `=>` как от чего-то вычисляемого. Еще одна проблема, общая с синтаксисом тел лямбда-выражений - невозможность выбросить исключение в теле-выражении:

```c#
class C {
  public int Property =>
    throw new NotImplementedException(); // unexpected 'throw' token
}
```

Это создает банальную проблему для IDE - непонятно какого вида "заглушку" генерировать в телах генерируемого кода, если пользователь будет требовать от IDE предпочитать форму свойств с телом-выражением. Еще одна проблема, касающаяся IDE - декларации свойств (и индексаторов) теперь иногда становятся для IDE полноценными "функциями" - конструкциями, содержащими в себе исполняемый код. До этого, в C# свойства являлись лишь контейнерами деклараций акцессоров, которые уже в свою очередь содержали исполняемый код. Это вынуждает переписать всю функциональность, вычисляющую по синтаксическому дереву в каком свойстве/акцессоре находится тот или иной исполняемый код.


### Инициализатор авто-свойств

* TODO: как работают, упомянуть порядок инициализации в статике
* TODO: semicolon в синтаксисе раньше не требовался
* TODO: полиморфизм и инициализатор (аналогично проблемам виртуальных событий)

### Авто-свойства только для чтения

* TODO: полиморфизм + get-only авто-свойства = CS8080
* TODO: правила вызова акцессора или записи в backing field (почти как readonly-поля)
* TODO: починили хаком структуры
* TODO: компиляция += по get-only автосвойствам

### Успешны ли изменения C# 6.0?

* TODO: стало сложнее отличать стейт от не-стейта
* TODO: get-only auto-property explicit implementation + невозможность инициализировать

## Misc

* "хочу свойства рядом с полями", никто не знает что такое backing field
* "хочу поля внутри свойств"
* [Serializable], IXmlSerializable, наличие сеттеров
* отсутствие extension properties (в C# 3.0)
* фичи должны проверять и поля, и свойства
* в C# уже ничего не починить, господь, жги!
* byref<'a> решает проблемы ref/out, но сложен
* Реализация INPC - новый billion dollar mistake
* Свойства не First-class
* Нет делегации реализации акцессоров
* [DebuggerDisplay] - приходится следить
* порядок акцессоров произволен
* нельзя сделать делегат из свойства (в C# 1.0)