---
layout: post
title: "Наследие прошлого или property hell (часть 5)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 4.0 и 5.0 - спасибо и на этом

Последовавшие за 3.0 релизы языка всегда были посвещаны какому-то относительно большому направлению работ (`dynamic` и `async`) и не вносили качественных изменений в дизайн свойств.

### Свойства-мутанты из COM'а

Из-за того, что в никак не умеревшем COM'е существуют свойства с формальными параметрами, а C# при потреблении метаданных игнорирует подобные "индексированные" свойства, то код:

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.get_Range("A1").Value = 42;
  spreadsheet.set_Width("B1", comSpreadsheet.get_Width("B1") + 1);
}
```

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.Range["A1"].Value = 42;
  spreadsheet.Width["B1"] += 1;
}
```


### Асинхронные свойства? Нет, спасибо

В версии языка 2.0, в C# были введены методы-итераторы, но не все знают что `yield return`/`yield break` работают еще и в `get`-акцессорах свойств:

```c#
class C {
  public IEnumerable<int> ImportantValues {
    get {
      yield return -1;
      yield return 0;
      yield return 42;
    }
  }
}
```



## C# 6.0 - одумаемся





С# 4.0 - проперти-мутанты из COM'а

C# 5.0 - нет async-свойств

C# 6.0 - expression-тела, инициализаторы, get-only автосвойства

* не кинуть исключение в => теле
* не повесить атрибут на геттер
* сильно отличающийся expression-синтаксис, слишком похоже на филды
* инициализаторы и semicolon в конце (который раньше не требовался)
* полиморфизм + get-only автосвойства = CS8080
* правила вызова акцессора или записи в backing field (как у readonly-полей, но не как с полями)
* починили хаком структуры, пересеклось с parameterless ctor'ами
* += по get-only автосвойствам
* стало сложнее отличать стейт от не-стейта (eще в C# 3.0, теперь от интерфейсного свойства не отличить)
* виртуальность и инициализатор
* появился выбор что использовать внутри класса - поле или свойство, и он нарушался когда приходили к автопропертям
* не понятно что 
* есть нетривиальный +=/-=, но нет ref/out (в VB есть, но )
* get-only auto-property explicit implementation + невозможность проинициализировать

Другое

* 
* "хочу свойства рядом с полями"
* [Serializable], IXmlSerializable, наличие сеттеров
* Object initializers is a disaster
* no extension properties
* фичи должны проверять и поля, и свойства
* дебаггер!
* в C# уже ничего не починить, господь, жги!
* byref<'a> немного лучше, но не совсем

Нерешенные проблемы

* INPC
* first-class
* нет возможности сделегировать реализацию акцессоров
* [DebuggerDisplay]
* порядок акцессоров
* нельзя сделать делегат из свойства
* нет делегирования

### Другие проблемы

* property-scoped fields
* explicit реализация свойств? не может добавлять акцессоры - это хорошо
* поля для приватных данных, приватные свойства редко встречаются