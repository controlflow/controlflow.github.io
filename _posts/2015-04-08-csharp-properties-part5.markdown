---
layout: post
title: "Дизайн и эволюция свойств в C# (часть 5)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 4.0 и 5.0 - спасибо и на этом

Последовавшие за 3.0 релизы языка всегда были посвящены какому-то относительно большому направлению работ (`dynamic` и `async`) и не вносили качественных изменений в дизайн свойств.

### Свойства-мутанты из COM'а

Из-за того, в COM существуют свойства с формальными параметрами, а C# при потреблении метаданных игнорирует большинство сущностей, невыразимых в самом C#, то код работы с подобными COM-объектами выглядит как-то так:

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.get_Range("A1").Value = 42;
  spreadsheet.set_Width("B1", comSpreadsheet.get_Width("B1") + 1);
}
```

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.Range["A1"].Value = 42;
  spreadsheet.Width["B1"] += 1;
}
```

### Асинхронные свойства? Нет, спасибо

В версии языка 2.0, в C# были введены методы-итераторы, но не все знают что конструкции `yield return`/`yield break` прекрасно работают еще и в `get`-аксессорах свойств (не существует значительных причин запрещать такие конструкции):

```c#
class C {
  public IEnumerable<int> ImportantValues {
    get {
      yield return -1;
      yield return 0;
      yield return 42;
    }
  }
}
```

Однако, в отличие от свойств-итераторов, C# 5.0 не стал вводить поддержку `async`-свойств. Опять же, с одной стороны это нарушает симметрию между методами и свойствами (которая, правда, и так уже много раз нарушена), а IDE должны все это обрабатывать (например, в рефакторингах типа "Convert method to property"). С другой стороны - конечно же асинхронный код явно не вписываются в концепцию чистоты и низкой задержки свойств, обсуждаемые нами ранее. Есть и другие проблемы: например, пришлось бы разрешать дополнительный модификатор `async` только на `get`-аксессоре (от модификатора нельзя избавиться из соображений обратной совместимости) и строго требовать от свойства возвращаемый тип `Task<T>`:

```c#
class C {
  public Task<int> Value {
    async get { return 42; }
  }
}
```

Выглядит это все крайне странно и бесполезно, при надобности легко обойти делегированием к `async`-методу, поэтому я доволен отсутствием `async`-свойств в C# (некоторые люди [все же просят](https://github.com/dotnet/roslyn/issues/3015)).