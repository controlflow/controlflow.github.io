---
layout: post
title: "Наследие прошлого или property hell (часть 5)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 4.0 и 5.0 - спасибо и на этом

Последовавшие за 3.0 релизы языка всегда были посвящены какому-то относительно большому направлению работ (`dynamic` и `async`) и не вносили качественных изменений в дизайн свойств.

### Свойства-мутанты из COM'а

Из-за того, в COM существуют свойства с формальными параметрами, а C# при потреблении метаданных игнорирует большинство сущностей, невыразимых в самом C#, то код работы с подобными COM-объектами выглядит как-то так:

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.get_Range("A1").Value = 42;
  spreadsheet.set_Width("B1", comSpreadsheet.get_Width("B1") + 1);
}
```

```c#
void M(COMSpreadsheet spreadsheet) {
  spreadsheet.Range["A1"].Value = 42;
  spreadsheet.Width["B1"] += 1;
}
```

### Асинхронные свойства? Нет, спасибо

В версии языка 2.0, в C# были введены методы-итераторы, но не все знают что конструкции `yield return`/`yield break` прекрасно работают еще и в `get`-акцессорах свойств (не существует значительных причин запрещать такие конструкции):

```c#
class C {
  public IEnumerable<int> ImportantValues {
    get {
      yield return -1;
      yield return 0;
      yield return 42;
    }
  }
}
```

Однако, в отличие от свойств-итераторов, C# 5.0 не стал вводить поддержку `async`-свойств. Опять же, с одной стороны это нарушает симметрию между методами и свойствами (которая, правда, и так уже много раз нарушена), а IDE должны все это обрабатывать (например, в рефакторингах типа "Convert method to property"). С другой стороны - конечно же асинхронный код явно не вписываются в концепцию чистоты и низкой задержки свойств, обсуждаемые нами ранее. Есть и другие проблемы: например, пришлось бы разрешать дополнительный модификатор `async` только на `get`-акцессоре (от модификатора нельзя избавиться из соображений обратной совместимости) и строго требовать от свойства возвращаемый тип `Task<T>`:

```c#
class C {
  public Task<int> Value {
    async get { return 42; }
  }
}
```

Выглядит это все крайне странно и бесполезно, при надобности легко обойти делегированием к `async`-методу, поэтому я доволен отсутствием `async`-свойств в C# (некоторые люди [все же просят](https://github.com/dotnet/roslyn/issues/3015)).

## C# 6.0 - одумались?

Последий (на момент написания статьи) релиз языка C# 6.0 ознаменовал завершение более чем пятилетнего переписывания компиляторов C# и VB.NET на управляемый код, в ходе которого команда не ставила перед собой задачу внесения в язык каких-либо "больших" языковых средств. Сфокусировавшись на относительно мелких улучшениях, C# 6.0 делает попытки исправить значительные недостатки дизайна свойтств, что не может не радовать.

### Синтаксис свойств с телом-выражением

Программируя на языках с C-подобным синтаксисом, все мы сталкивались с большим количеством тривиальных методов-"однострочников", особенно состоящих из единственного `return`-statement'а. C# 6.0 пытается адресовать проблему синтаксического шума из-за необходимости в блоке и statement'е, вводя для деклараций методов (и операторов, но не конструкторов) синтаксис тел-выражений, аналогичных привычному C# разработчикам синтаксису тел лямбда-выражений:

```c#
class C {
  public int StatementBodiedMethod(int x) { return x + 42; }
  public int ExpressionBodiedMethod(int x) => x + 42;
}
```

Конечно же, дизайнеры языка C# не могли обойти стороной и синтаксис более сложных (синтаксически) членов типов, имеющие внутри себя декларации знакомых нам акцессоров - свойства и индексаторы:

```c#
class C {
  public int StatementBodiedProperty { get { return 42; } }
  public int ExpressionBodiedProperty => 42;

  public string this[int index] { get { return index.ToString(); } }
  public string this[int index] => index.ToString();
}
```

Как можно заметить, в этом случае синтаксический сахар тел-выражений скрывает за собой немного больше, чем в случае методов и операторов - отсутствует явная декларация `get`-акцессора. Таким образом, в синтаксис с телом-выражения могут быть переписаны свойства только с единственным `get`-акцессором (с `public` уровнем доступа) без атрибутов:

```c#
abstract class A {
  public virtual int Value { protected get; set; }
  public virtual string Text { get; set; }
}

class C : A {
  public override int Value => 42; // error
  public override string Text {
    [SomeAttribute] get { return "abc"; }
  }
}
```

Оба случая крайне редкие (за первый надо жестоко наказывать), поэтому ничего страшного в подобных ограничениях нет, лишь немного больше работы для IDE. Однако, из-за 


При этом, 


 Из этого следует не только очевидное

 следствие, о том что тела-выражения могут иметь 



```c#
class C : B {
  public override bool CanRead {
    get {
      return true;
    }
  }
  // vs.
  public override bool CanRead {
    get { return true; }
  }
  // vs.
  public override bool CanRead { get { return true; } }
  // vs.
  public override bool CanRead => true;
}
```



```c#
class C {
  public int Field = 42;
  public int Property => 42;
}
```

```c#
class C {
  pubint int Property =>
    throw new NotImplementedException();
}
```









* TODO: внешний для выражений акцессор неявный
* TODO: свойство становится "функцией"
* TODO: хорошо, что похоже на лямбда-выражения
* TODO: не повесить атрибут на get-акцессор
* TODO: не бросить исключение (какие заглушки генерировать IDE?)
* TODO: слишком похоже на поля (один символ разницы)
* TODO: нельзя будет ввести новые модификаторы на акцессорах

### Инициализатор авто-свойств

* TODO: как работают, упомянуть порядок инициализации в статике
* TODO: semicolon в синтаксисе раньше не требовался
* TODO: полиморфизм и инициализатор (аналогично проблемам виртуальных событий)

### Авто-свойства только для чтения

* TODO: полиморфизм + get-only авто-свойства = CS8080
* TODO: правила вызова акцессора или записи в backing field (почти как readonly-поля)
* TODO: починили хаком структуры
* TODO: компиляция += по get-only автосвойствам

### Успешны ли изменения C# 6.0?

* TODO: стало сложнее отличать стейт от не-стейта
* TODO: get-only auto-property explicit implementation + невозможность инициализировать

## Misc

* "хочу свойства рядом с полями", никто не знает что такое backing field
* "хочу поля внутри свойств"
* [Serializable], IXmlSerializable, наличие сеттеров
* отсутствие extension properties (в C# 3.0)
* фичи должны проверять и поля, и свойства
* в C# уже ничего не починить, господь, жги!
* byref<'a> решает проблемы ref/out, но сложен
* Реализация INPC - новый billion dollar mistake
* Свойства не First-class
* Нет делегации реализации акцессоров
* [DebuggerDisplay] - приходится следить
* порядок акцессоров произволен
* нельзя сделать делегат из свойства (в C# 1.0)