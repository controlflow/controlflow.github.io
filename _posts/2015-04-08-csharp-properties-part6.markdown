---
layout: post
title: "Дизайн и эволюция свойств в C# (часть 6)"
date: 2015-04-08 17:54:00
tags: csharp properties design
---

## C# 6.0 - одумались?

Последий (на момент написания статьи) релиз языка C# 6.0 ознаменовал завершение более чем пятилетнего переписывания компиляторов C# и VB.NET на управляемый код, в ходе которого команда не ставила перед собой задачу внесения в язык каких-либо "больших" языковых средств. Сфокусировавшись на относительно мелких улучшениях, C# 6.0 делает попытки исправить значительные недостатки дизайна свойтств, что не может не радовать.

### Свойства с телом-выражением

Программируя на языках с C-подобным синтаксисом, все мы сталкивались с большим количеством тривиальных методов-"однострочников", особенно состоящих из единственного `return`-statement'а. C# 6.0 пытается адресовать проблему синтаксического шума из-за необходимости в блоке и statement'е, вводя для деклараций методов (и операторов, но не конструкторов) синтаксис тел-выражений, аналогичных привычному C# разработчикам синтаксису тел лямбда-выражений:

```c#
class C {
  public int StatementBodiedMethod(int x) { return x + 42; }
  public int ExpressionBodiedMethod(int x) => x + 42;
}
```

Конечно же, дизайнеры языка C# не могли обойти стороной и синтаксис более сложных (синтаксически) членов типов, имеющие внутри себя декларации знакомых нам акцессоров - свойства и индексаторы:

```c#
class C {
  public int StatementBodiedProperty { get { return 42; } }
  public int ExpressionBodiedProperty => 42;

  public string this[int index] { get { return index.ToString(); } }
  public string this[int index] => index.ToString();
}
```

Как можно заметить, в этом случае синтаксический сахар тел-выражений скрывает за собой немного больше, чем в случае методов и операторов - отсутствует явная декларация `get`-акцессора. Таким образом, в синтаксис с телом-выражения могут быть переписаны свойства только с единственным `get`-акцессором (с `public` уровнем доступа) без атрибутов:

```c#
abstract class A {
  public virtual int Value { protected get; set; }
  public virtual string Text { get; set; }
}

class C : A {
  public override int Value => 42; // error
  public override string Text {
    [SomeAttribute] get { return "abc"; }
  }
}
```

Оба случая крайне редкие (за первый надо жестоко наказывать), поэтому ничего страшного в подобных ограничениях нет, лишь немного больше работы для IDE. Однако, из-за таких мелочей мы на самом деле не можем полагаться, что каждое свойство только для чтения можно переписать в вид с телом-выражением. Более того, не смотря на синтаксис, который как-бы говорит "я - вычисляемое свойство только для чтения", из-за описанных ранее полиморфных акцессоров, свойство с телом-выражением вполне может быть доступно и для записи:

```c#
class A {
  public virtual int Value { get; set; }
}

class C : A {
  public override int Value => 42; // readonly? no
  public void M() {
    Value ++; // ok
  }
}
```

### Немного о синтаксисе тел-выражений

Нововведения C# 6.0 у меня вызывали сначала только положительные эмоции, так как наконец адресавали известные проблемные места языка. Например, понимаешь, что вокруг языка просто исчезнут разные бесполезные споры как форматировать тривиальные свойства (правда, могут начаться споры использовать ли вообще свойства с телами-выражениями):

```c#
class C : B {
  public override bool CanRead {
    get {
      return true;
    }
  }
  // vs.
  public override bool CanRead {
    get { return true; }
  }
  // vs.
  public override bool CanRead { get { return true; } }
  // vs.
  public override bool CanRead => true;
}
```

Разобравшись немного получше, задумываешсья что синтаксис тел-выражений не позволит (или как минимум затруднит) в будущем ввести какие-нибудь новые модификаторы на акцессорах, но таких пока не приходит в голову (может быть какой-нибудь `lazy`?). Задумавшись еще глубже, становится страшно представлять как придется объяснять новичку в C# в чем разница между двумя языковыми конструкциями, различающиеся буквально одним символом:

```c#
class C {
  public int Field = 42;
  public int Property => 42;
}
```

Почему после `=` выражение находится в статическом контексте и вычисляется при инициализации класса, а выражение после `=>` вычисляется каждый раз и позволяет пользоваться `this`? Синтаксис тел-выражений смазывает различие между совершенно разными конструкциями, предназначенными для разных целей, только с опытом программирования на C# вырабатывается, в некотором роде, ожидание от конструкции с токеном `=>` как от чего-то вычисляемого. Еще одна проблема, общая с синтаксисом тел лямбда-выражений - невозможность выбросить исключение в теле-выражении:

```c#
class C {
  public int Property =>
    throw new NotImplementedException(); // unexpected 'throw' token
}
```

Это создает банальную проблему для IDE - непонятно какого вида "заглушку" генерировать в телах генерируемого кода, если пользователь будет требовать от IDE предпочитать форму свойств с телом-выражением. Еще одна проблема, касающаяся IDE - декларации свойств (и индексаторов) теперь иногда становятся для IDE полноценными "функциями" - конструкциями, содержащими в себе исполняемый код. До этого, в C# свойства являлись лишь контейнерами деклараций акцессоров, которые уже в свою очередь содержали исполняемый код. Это вынуждает переписать всю функциональность, вычисляющую по синтаксическому дереву в каком свойстве/акцессоре находится тот или иной исполняемый код.

### Инициализаторы авто-свойств

Второй вкусностью, привнесенной C# 6.0 является синтаксис инициализаторов авто-свойств, полностью экивалентный синтаксису инициализаторов полей и field-like событий (в ходе разработки C# 6.0 чуть не упустили инициализаторы массивов, редко используемые на практике, но важные с точки зрения симметрии с декларациями полей/событий):

```c#
class Person {
  public string Name { get; set; } = string.Empty;
  public int[] Array { get; set; } = { 1, 2, 3 }; // array initializer
}
```

Из-за первоначального синтаксиса свойств, не требовавшего символ `;` в конце декларации свойств (в отличие от полей и field-like событий), маленьким "костылем" является то, что синтаксически символ `;` в инициализаторе авто-свойства относится к самому иницализатору, а не декларации свойства. Поэтому, например, отличается процедура удаления инициализаторов полей и авто-свойств, по-разному работают IDE-функциональность типа "extend selection".

Еще одним маленьким нюансом является то, что авто-свойства практически не отличаются синтаксически от обычных деклараций свойств (используют те же правила грамматики C#), что вынуждает парсер всегда ожидать и разбирать синтаксис инициализатора после декларации акцессоров любого свойства, позже генерируя ошибку компиляции в случае, если инициализируют не авто-свойство. Более того, вообще ответ на вопрос "а авто-свойство ли это?" в IDE не так прост, как кажется - отсутствие тел у деклараций акцессоров встречается у абстрактных и интерфейсных свойств.

Что касается семантики, то инициализаторы авто-свойств работают аналогично инициализаторам полей - инициализация случается до вызова тела конструктора (включая вызов базового конструктора). Из этого следует простое правило пересечения с полиморфизмом - инициализатор записывает значение в поле авто-свойства, минуя `set`-акцессор (потенциально виртуальный), иначе это привело бы к виртуальным вызовам до вызова конструктора производного класса.

```c#
class Base {
  public virtual string Text { get; set; } = string.Empty;
}

class Derived : Base {
  public override string Text {
    set { throw new InvalidOperationException("Do not mutate me!"); }
  }
}

var derived = new Derived(); // ok
Assert.AreEqual(derived.Text, string.Empty); // ok
```

Из-за появления неполиморфного доступа к полиморфному члену с состоянием, мы получаем часть проблем виртуальных field-like событий. Например, инициализированное авто-свойство могут полностью переопределить и состояние авто-свойства (с пустым списком) станет недостежимым (даже внутри декларации `Base`):

```c#
class Base {
  public virtual List<T> Items { get; set; } = new List<T>();
}

class Derived : Base {
  public override List<T> Items { get { ... } set { ... } }
}
```

Создается ощущение, что таким образом у нас "протекла" абстракция авто-свойства - мы "узнали" о существовании поля. Опытный читатель мог заметить, что этой возможности добраться напрямую до поля авто-свойства нам не хватало чтобы удовлетворить анализ инициализации структуры. Это действительно так но, к сожалению, из-за запрета инициализаторов на членах экземпляра в декларации структуры, проблему анализа инициализации структуры решить через инициализаторы авто-свойств не получится.

Порядок инициализации авто-свойств тоже эквивалентен правилам полей - инициализаторы вычисляются в порядке деклараций соответствующих авто-свойств, а порядок инициализации между частами `partial`-типов не определен. Это становится важно в декларациях статических свойств, так как в статике иногда встречаются зависимости между инициализированными членами. Из спецификации не понятен лишь порядок в инициализации *разных* членов классов, однако компилятор ведет себя наиболее предсказуемым образом (иициализаторы исполняются в порядке деклараций, независимо от разновидности члена типа):

```c#
class C {
  public static readonly int Field = EvaluatedFirst();
  public static int AutoProperty1 { get; set; } = EvaluatedSecond();
  public static int AutoProperty2 { get; set; } = EvaluatedThird();
  public static event EventHandler Event = EvaluatedFourth();
}
```

### Авто-свойства только для чтения



* TODO: полиморфизм + get-only авто-свойства = CS8080
* TODO: правила вызова акцессора или записи в backing field (почти как readonly-поля)
* TODO: починили хаком структуры
* TODO: компиляция += по get-only автосвойствам

### field:-target

### Успешны ли изменения C# 6.0?

* TODO: стало сложнее отличать стейт от не-стейта
* TODO: get-only auto-property explicit implementation + невозможность инициализировать

## Misc

* "хочу свойства рядом с полями", никто не знает что такое backing field
* "хочу поля внутри свойств"
* [Serializable], IXmlSerializable, наличие сеттеров
* отсутствие extension properties (в C# 3.0)
* фичи должны проверять и поля, и свойства
* в C# уже ничего не починить, господь, жги!
* byref<'a> решает проблемы ref/out, но сложен
* Реализация INPC - новый billion dollar mistake
* Свойства не First-class
* Нет делегации реализации акцессоров
* [DebuggerDisplay] - приходится следить
* порядок акцессоров произволен
* нельзя сделать делегат из свойства (в C# 1.0)